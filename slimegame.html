<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slime Care Game | Happy Birthday!</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&family=Pacifico&display=swap" rel="stylesheet">
    <style>
        /* ... (existing general, nav, page-wrapper, header, main, decorative, responsive styles remain the same) ... */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f1a1c2;
            color: #333;
            min-height: 100vh;
            padding-left: 100px;
            text-align: center;
            position: relative;
            overflow-x: hidden;
        }

        .nav-container {
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            width: 100px;
            background-color: #2a0a3a;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 30px;
            z-index: 1000;
            box-shadow: 4px 0 10px rgba(0, 0, 0, 0.2);
            border-right: 3px solid #ff9ec6;
        }

        .nav-item {
            width: 100%;
            text-align: center;
            padding: 15px 0;
            margin: 10px 0;
            color: white;
            font-size: 0.9em;
            text-decoration: none;
            transition: all 0.3s;
        }

        .nav-item:hover {
            background-color: #9b4d96;
            transform: scale(1.05);
        }

        .nav-item img {
            width: 50px;
            height: 50px;
            object-fit: contain;
            margin-bottom: 8px;
        }

        .active {
            background-color: #ff66a3;
            font-weight: bold;
        }

        .page-wrapper {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
        }

        header {
            background-color: #9b4d96;
            color: white;
            padding: 20px;
            font-size: 2em;
            text-transform: uppercase;
            font-weight: bold;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        .main-content-area { /* Renamed main for clarity */
            width: 100%;
            padding: 40px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 40px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .bow {
            position: absolute;
            width: 40px;
            height: 40px;
            background: url('https://i.imgur.com/tA7aPg4.png') center/contain no-repeat;
            z-index: 10;
        }

        .hearts-container {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }

        .heart {
            position: absolute;
            width: 30px;
            height: 30px;
            color: #f5a9bc;
            font-size: 30px;
            opacity: 0.7;
            animation: floatUp 15s linear infinite;
        }

        @keyframes floatUp {
            0% { transform: translateY(100vh) scale(0.5) rotate(0deg); opacity: 0; }
            10% { opacity: 0.7; }
            90% { opacity: 0.7; }
            100% { transform: translateY(-20vh) scale(1.2) rotate(360deg); opacity: 0; }
        }

        .header-bow-left { top: -15px; left: -15px; }
        .header-bow-right { top: -15px; right: -15px; }
        .main-bow-tl { top: -15px; left: -15px; }
        .main-bow-tr { top: -15px; right: -15px; }
        .main-bow-bl { bottom: -15px; left: -15px; }
        .main-bow-br { bottom: -15px; right: -15px; }

        @media (max-width: 768px) {
            body { padding-left: 80px; }
            .nav-container { width: 80px; }
            .nav-item { font-size: 0; padding: 15px 0; }
            .nav-item img { width: 40px; height: 40px; margin-bottom: 0; }
            .nav-item span { font-size: 24px !important; }
            header { font-size: 1.8em; padding: 15px; }
            .main-content-area { padding: 25px; } /* Adjusted for new class name */
            #slimeCanvas {
                width: 100% !important; 
                max-width: 350px !important; /* Keep canvas from getting too huge on small screens */
                height: auto !important; 
                 /* Adjust height based on new slime size if canvas fixed height */
            }
            .slime-name-header { font-size: 1.8em !important; }
            .status-bars { flex-direction: column; width: 90% !important; gap: 10px !important; }
            .bar-container { width: 100% !important; }
            .customization { width: 90% !important; }
        }


        /* ===== SLIME GAME SPECIFIC STYLES ===== */
        .slime-container { /* New container for name + canvas */
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            background-color: #fff0f5; /* LavenderBlush - cute background for the slime area */
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 2px 6px rgba(155, 77, 150, 0.2); /* Soft purple shadow */
            border: 2px dashed #ffc0cb; /* Pink dashed border */
        }

        .slime-name-header {
            font-family: 'Pacifico', cursive;
            font-size: 2.2em; /* Bigger name */
            color: #9b4d96; /* Theme purple */
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        #slimeCanvas {
            border: 3px solid #a0d2eb; 
            background-color: #e0ffff; 
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border-radius: 10px;
            /* width and height set in JS for bigger slime */
        }

        .status-bars { /* Styles mostly okay */ }
        .status-bar { /* Styles mostly okay */ }
        .status-bar label { /* Styles mostly okay */ }
        .bar-container { /* Styles mostly okay */ }
        .bar-fill { /* Styles mostly okay */ }
        .controls { /* Styles mostly okay */ }
        .controls button { /* Styles mostly okay */ }
        #feedButton { /* Styles mostly okay */ }
        #feedButton:hover { /* Styles mostly okay */ }
        #playButton { /* Styles mostly okay */ }
        #playButton:hover { /* Styles mostly okay */ }
        .customization { /* Styles mostly okay, maybe slight color tweaks */
            background-color: #fff8fa;
        }
        .customization h3 { /* Styles mostly okay */ }
        .customization p { /* Styles mostly okay */ }
        .color-picker, .hat-picker { /* Styles mostly okay */ }
        .color-btn { /* Styles mostly okay */ }
        .hat-btn { /* Styles mostly okay */ }
        #slimeMessage { /* Styles mostly okay */ }

    </style>
</head>
<body>
    <div class="nav-container">
        <!-- ... navigation items ... -->
        <a href="index.html" class="nav-item home">
            <img src="https://i.imgur.com/ZAl2gbp.png" alt="Home"> Home
        </a>
        <a href="loveletters.html" class="nav-item letters">
            <img src="https://i.imgur.com/ZVhcvD8.png" alt="Love Letters"> Love Letters
        </a>
        <a href="lovecalculator.html" class="nav-item calculator">
            <img src="https://i.imgur.com/megzmKr.png" alt="Love Calculator"> Love Calculator
        </a>
        <a href="movies.html" class="nav-item movies">
            <img src="https://i.imgur.com/gzW8uSH.png" alt="Movie Picker"> Movie Picker
        </a>
        <a href="bookdate.html" class="nav-item bookdate">
            <img src="https://i.imgur.com/megzmKr.png" alt="Book a Date"> Book a Date
        </a>
        <a href="timezone.html" class="nav-item timezone">
            <img src="https://i.imgur.com/ZwOw9QN.png" alt="Time Bridge"> Time Bridge
        </a>
        <a href="slimegame.html" class="nav-item slimegame"> 
            <img src="https://i.imgur.com/QY1Y0nC.png" alt="Slime Game Icon"> Slime Game
        </a>
    </div>

    <div class="page-wrapper">
        <header>
            Slime Pet Care üíñ
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow header-bow-left">
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow header-bow-right">
        </header>

        <div class="main-content-area"> <!-- Changed main to div with class for clarity -->
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow main-bow-tl">
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow main-bow-tr">
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow main-bow-bl">
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow main-bow-br">
            
            <div class="slime-container"> <!-- New container for name + canvas -->
                <div class="slime-name-header">Sui</div>
                <canvas id="slimeCanvas" width="450" height="350"></canvas> <!-- Increased canvas size -->
            </div>

            <div class="status-bars">
                <!-- ... status bars ... -->
                <div class="status-bar">
                    <label for="hungerBar">Hunger:</label>
                    <div class="bar-container">
                        <div id="hungerBar" class="bar-fill"></div>
                    </div>
                    <span id="hungerValue">100/100</span>
                </div>
                <div class="status-bar">
                    <label for="happinessBar">Happiness:</label>
                    <div class="bar-container">
                        <div id="happinessBar" class="bar-fill"></div>
                    </div>
                    <span id="happinessValue">100/100</span>
                </div>
            </div>

            <div class="controls">
                <!-- ... controls ... -->
                <button id="feedButton">Feed Sui üçñ</button>
                <button id="playButton">Play with Sui üòä</button>
            </div>

            <div class="customization">
                <!-- ... customization ... -->
                <h3>Customize Sui!</h3>
                <div class="color-picker">
                    <p>Color:</p>
                    <button class="color-btn" data-color="rgba(144, 238, 144, 1)" style="background-color: lightgreen;">Green</button>
                    <button class="color-btn" data-color="rgba(135, 206, 250, 1)" style="background-color: lightskyblue;">Blue</button>
                    <button class="color-btn" data-color="rgba(255, 182, 193, 1)" style="background-color: lightpink;">Pink</button>
                    <button class="color-btn" data-color="rgba(255, 215, 0, 1)" style="background-color: gold;">Gold</button>
                    <button class="color-btn" data-color="rgba(221, 160, 221, 1)" style="background-color: plum;">Plum</button>
                </div>
                <div class="hat-picker">
                    <p>Hat:</p>
                    <button class="hat-btn" data-hat="üëë">üëë</button>
                    <button class="hat-btn" data-hat="üé©">üé©</button>
                    <button class="hat-btn" data-hat="ü•≥">ü•≥</button>
                    <button class="hat-btn" data-hat="‚≠ê">‚≠ê</button>
                    <button class="hat-btn" data-hat="üçì">üçì</button>
                    <button class="hat-btn" data-hat="none">No Hat</button>
                </div>
            </div>
            <p id="slimeMessage">Sui is content.</p>
        </div>
    </div>

    <div class="hearts-container" id="hearts-container"></div>

    <script>
        // ... (createHearts, setActiveNav functions remain the same) ...
        function createHearts() {
            const container = document.getElementById('hearts-container');
            if (!container) return;
            const heartCount = container.children.length;
            if (heartCount > 50) return; 
            for (let i = 0; i < 15; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                heart.innerHTML = 'üíú'; // Changed to purple to match theme
                heart.style.left = `${Math.random() * 100}vw`;
                heart.style.animationDuration = `${10 + Math.random() * 10}s`; 
                heart.style.animationDelay = `${Math.random() * 5}s`;
                heart.style.fontSize = `${15 + Math.random() * 15}px`; 
                heart.style.opacity = `${0.5 + Math.random() * 0.4}`; 
                container.appendChild(heart);
                heart.addEventListener('animationend', () => {
                    heart.remove();
                });
            }
        }
        
        function setActiveNav() {
            const navItems = document.querySelectorAll('.nav-container .nav-item');
            let path = window.location.pathname.split("/").pop();
            if (path === "") {
                path = "index.html";
            }
            navItems.forEach(item => {
                item.classList.remove('active');
                if (item.getAttribute('href') === path) {
                    item.classList.add('active');
                }
            });
        }

        // ===== SLIME GAME SCRIPT =====
        const canvas = document.getElementById('slimeCanvas');
        const ctx = canvas.getContext('2d');

        // ... (button, bar, display element consts remain the same) ...
        const feedButton = document.getElementById('feedButton');
        const playButton = document.getElementById('playButton');
        const hungerBar = document.getElementById('hungerBar');
        const happinessBar = document.getElementById('happinessBar');
        const hungerValueDisplay = document.getElementById('hungerValue');
        const happinessValueDisplay = document.getElementById('happinessValue');
        const slimeMessage = document.getElementById('slimeMessage');
        const colorButtons = document.querySelectorAll('.color-btn');
        const hatButtons = document.querySelectorAll('.hat-btn');


        const MAX_STAT = 100;
        const STAT_DECAY_RATE = 1;
        const FEED_AMOUNT = 30;
        const PLAY_AMOUNT = 25;
        const TICK_INTERVAL = 2000;

        let slime = {
            hunger: MAX_STAT,
            happiness: MAX_STAT,
            x: canvas.width / 2,
            y: canvas.height - 90, // Adjusted for larger slime, ground Y of center-bottom
            baseWidth: 130,    // BIGGER SLIME
            baseHeight: 110,   // BIGGER SLIME
            baseColor: 'rgba(144, 238, 144, 1)', 
            color: 'rgba(144, 238, 144, 1)',    
            hat: null, 
            hatSize: 55, // BIGGER HAT
            eyeColor: 'black',
            pupilColor: 'white',
            eyeOffsetX: 28, // Scaled for bigger slime
            eyeOffsetY: -25, // Scaled for bigger slime
            eyeRadius: 14,  // Scaled for bigger slime
            pupilRadius: 6, // Scaled for bigger slime
            mouthType: 'smile',
            isBouncing: false,
            bounceHeight: 0,
            animationTimer: 0
        };

        function getGradientColors(rgbaString, state = 'normal') {
            const match = rgbaString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (!match) return [rgbaString, rgbaString];

            let r = parseInt(match[1]);
            let g = parseInt(match[2]);
            let b = parseInt(match[3]);
            let a = match[4] ? parseFloat(match[4]) : 1; // Ensure alpha is 1 for base

            let modR = r, modG = g, modB = b;
            // Modify base color for state BEFORE calculating gradient variant
            if (state === 'sad') {
                modR = Math.max(0, r - 40); modG = Math.max(0, g - 40); modB = Math.max(0, b - 40);
            } else if (state === 'neutral') {
                modR = Math.max(0, r - 20); modG = Math.max(0, g - 20); modB = Math.max(0, b - 20);
            }

            // Create a noticeably lighter color for the top of the gradient
            // Increase difference for more pronounced gradient
            const lighterR = Math.min(255, modR + 60); // Increased difference from +30 to +60
            const lighterG = Math.min(255, modG + 60);
            const lighterB = Math.min(255, modB + 60);
            
            // Ensure full opacity for gradient colors unless specifically reducing for effect
            return [`rgba(${lighterR}, ${lighterG}, ${lighterB}, ${a})`, `rgba(${modR}, ${modG}, ${modB}, ${a})`];
        }


        function drawSlime() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let currentHeight = slime.baseHeight - slime.bounceHeight;
            let currentY = slime.y + slime.bounceHeight / 2; 
            let slimeBodyTopY = currentY - currentHeight;      
            let slimeBodyBottomY = currentY;                   

            // Determine current state for gradient modification
            let currentState = 'normal';
            if (slime.animationTimer > 0) { // During animation, use animation color directly
                 currentState = 'animation';
            } else if (slime.hunger < 30 || slime.happiness < 30) {
                currentState = 'sad';
            } else if (slime.hunger < 60 || slime.happiness < 60) {
                currentState = 'neutral';
            }
            
            // For animations, slime.color is already set. For normal states, derive from baseColor.
            const colorForGradient = (currentState === 'animation') ? slime.color : slime.baseColor;
            const gradientColors = getGradientColors(colorForGradient, currentState);
            
            const gradient = ctx.createLinearGradient(slime.x, slimeBodyTopY, slime.x, slimeBodyBottomY);
            gradient.addColorStop(0, gradientColors[0]); 
            gradient.addColorStop(1, gradientColors[1]); 

            ctx.fillStyle = gradient;

            ctx.beginPath();
            ctx.moveTo(slime.x, slimeBodyBottomY);
            ctx.bezierCurveTo(
                slime.x - slime.baseWidth / 1.5, slimeBodyBottomY + 15, // Adjusted for bigger slime
                slime.x - slime.baseWidth / 1.8, slimeBodyTopY - 30,    // Adjusted for bigger slime
                slime.x, slimeBodyTopY                               
            );
            ctx.bezierCurveTo(
                slime.x + slime.baseWidth / 1.8, slimeBodyTopY - 30,    
                slime.x + slime.baseWidth / 1.5, slimeBodyBottomY + 15, 
                slime.x, slimeBodyBottomY                               
            );
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.beginPath();
            ctx.ellipse(slime.x, slimeBodyBottomY + 8, slime.baseWidth / 2.1, 8, 0, 0, Math.PI * 2); // Bigger shadow
            ctx.fill();

            if (slime.hat && slime.hat !== 'none') {
                ctx.save(); // Save context state before drawing hat
                ctx.fillStyle = 'black'; // Explicitly set opaque color for hat text
                ctx.font = `${slime.hatSize}px 'Arial', 'sans-serif'`; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle'; 

                let hatYPosition = slimeBodyTopY - (slime.hatSize * 0.3) + (slime.bounceHeight * 0.5); // Adjusted factor
                if (slime.hat === 'üëë') hatYPosition -= 5;
                if (slime.hat === 'üé©') hatYPosition += 3;
                if (slime.hat === 'üçì') hatYPosition -= 4;
                if (slime.hat === '‚≠ê') hatYPosition -= 2;
                if (slime.hat === 'ü•≥') hatYPosition -= 2;


                ctx.fillText(slime.hat, slime.x, hatYPosition);
                ctx.restore(); // Restore context state
            }

            const eyeCenterY = slimeBodyTopY + slime.baseHeight * 0.38 + slime.bounceHeight * 0.1; // Adjusted Y for eyes
            const leftEyeX = slime.x - slime.eyeOffsetX;
            const rightEyeX = slime.x + slime.eyeOffsetX;
            const eyeY = eyeCenterY + slime.eyeOffsetY;

            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(leftEyeX, eyeY, slime.eyeRadius, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(rightEyeX, eyeY, slime.eyeRadius, 0, Math.PI * 2); ctx.fill();

            ctx.fillStyle = slime.eyeColor;
            let pupilOffsetY = 0;
            if (slime.mouthType === 'happy' || slime.mouthType === 'smile') pupilOffsetY = -2; // Scaled
            if (slime.mouthType === 'sad') pupilOffsetY = 2; // Scaled

            ctx.beginPath(); ctx.arc(leftEyeX, eyeY + pupilOffsetY, slime.pupilRadius, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(rightEyeX, eyeY + pupilOffsetY, slime.pupilRadius, 0, Math.PI * 2); ctx.fill();

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2.5; // Slightly thicker for bigger slime
            ctx.beginPath();
            const mouthBaseY = eyeY + slime.eyeRadius + 5; // Scaled
            switch (slime.mouthType) {
                case 'smile': case 'happy':
                    ctx.arc(slime.x, mouthBaseY, 12, 0.1 * Math.PI, 0.9 * Math.PI); break; // Bigger smile
                case 'ooh':
                    ctx.arc(slime.x, mouthBaseY + 4, 6, 0, Math.PI * 2); break; // Bigger 'ooh'
                case 'sad':
                    ctx.arc(slime.x, mouthBaseY + 10, 12, 1.1 * Math.PI, 1.9 * Math.PI); break; // Bigger sad
                case 'neutral': default:
                    ctx.moveTo(slime.x - 12, mouthBaseY + 4); ctx.lineTo(slime.x + 12, mouthBaseY + 4); break; // Bigger neutral
            }
            ctx.stroke();
        }

        function determineSlimeColorAndExpression() {
            // This function now primarily sets the mouthType and message.
            // The actual color for the gradient is handled in drawSlime by getGradientColors using slime.baseColor and state.
            if (slime.hunger < 30 || slime.happiness < 30) {
                slime.mouthType = 'sad';
                setMessage("Sui looks sad and hungry!");
            } else if (slime.hunger < 60 || slime.happiness < 60) {
                slime.mouthType = 'neutral';
                setMessage("Sui seems a bit bored or peckish.");
            } else {
                slime.mouthType = 'smile';
                setMessage("Sui is content!");
            }
            // slime.color will be set to specific animation colors by feed/play functions.
            // Otherwise, drawSlime uses slime.baseColor + state for gradient.
        }


        function updateSlimeState() {
            // ... (stat decay and clamping same as before) ...
            slime.hunger -= STAT_DECAY_RATE;
            slime.happiness -= STAT_DECAY_RATE;
            slime.hunger = Math.max(0, slime.hunger);
            slime.happiness = Math.max(0, slime.happiness);

            if (slime.animationTimer <= 0) {
                determineSlimeColorAndExpression();
                // Ensure slime.color is reset to baseColor if no animation
                // This is handled by drawSlime logic now using slime.baseColor and state
            } else {
                slime.animationTimer--;
                if (slime.animationTimer === 0) {
                    slime.isBouncing = false;
                    slime.bounceHeight = 0;
                    determineSlimeColorAndExpression(); // Re-evaluate mood
                }
            }

            if (slime.isBouncing) {
                slime.bounceHeight = Math.abs(Math.sin(Date.now() * 0.015)) * 15; // Bigger bounce for bigger slime
            }

            updateStatusBars();
            drawSlime();
        }

        function feedSlime() {
            // ... (logic mostly same) ...
            if (slime.hunger < MAX_STAT) {
                slime.hunger = Math.min(MAX_STAT, slime.hunger + FEED_AMOUNT);
                slime.happiness = Math.min(MAX_STAT, slime.happiness + PLAY_AMOUNT / 3);
                setMessage("Yum! Sui enjoyed the food!");
                slime.mouthType = 'ooh';
                slime.color = 'rgba(173, 255, 47, 1)'; // Animation color (will be used by getGradientColors)
                slime.animationTimer = 2; // e.g., 2 game ticks
                triggerBounce();
            } else {
                setMessage("Sui is already full!");
            }
            updateStatusBars(); 
            drawSlime(); 
        }

        function playWithSlime() {
            // ... (logic mostly same) ...
            if (slime.happiness < MAX_STAT) {
                slime.happiness = Math.min(MAX_STAT, slime.happiness + PLAY_AMOUNT);
                setMessage("Whee! Sui had fun playing!");
                slime.mouthType = 'happy';
                slime.color = 'rgba(135, 206, 250, 1)'; // Animation color
                slime.animationTimer = 2; // e.g., 2 game ticks
                triggerBounce(true);
            } else {
                setMessage("Sui is perfectly happy right now!");
            }
            updateStatusBars();
            drawSlime();
        }

        // ... (triggerBounce, setMessage, color/hat button listeners, gameIntervalId, startGame remain largely the same) ...
        function triggerBounce(longer = false) {
            slime.isBouncing = true;
            const duration = longer ? 1500 : 750;
            if (slime.animationTimer === 0) {
                setTimeout(() => {
                    if (slime.animationTimer <= 0) { 
                        slime.isBouncing = false;
                        slime.bounceHeight = 0;
                        drawSlime(); 
                    }
                }, duration);
            }
        }
        function setMessage(msg) { slimeMessage.textContent = msg; }

        colorButtons.forEach(button => {
            button.addEventListener('click', () => {
                slime.baseColor = button.dataset.color;
                if (slime.animationTimer <= 0) { // Only change expression if not animating
                    determineSlimeColorAndExpression();
                }
                drawSlime(); 
            });
        });
        hatButtons.forEach(button => {
            button.addEventListener('click', () => {
                const newHat = button.dataset.hat;
                slime.hat = (newHat === 'none') ? null : newHat;
                drawSlime(); 
            });
        });
        feedButton.addEventListener('click', feedSlime);
        playButton.addEventListener('click', playWithSlime);
        let gameIntervalId = null;

        function startGame() {
            slime.x = canvas.width / 2;
            // Adjust Y for the new, larger slime. Center its mass a bit above the canvas bottom.
            slime.y = canvas.height - (slime.baseHeight / 2) - 30; 

            determineSlimeColorAndExpression(); 
            updateStatusBars();
            drawSlime(); // Initial draw
            if(gameIntervalId) clearInterval(gameIntervalId);
            gameIntervalId = setInterval(updateSlimeState, TICK_INTERVAL);
        }


        window.addEventListener('load', () => {
            createHearts(); 
            setInterval(createHearts, 15000); 
            setActiveNav(); 

            if (document.getElementById('slimeCanvas') && document.getElementById('feedButton') && document.getElementById('playButton')) { 
                 startGame();
            }
        });
    </script>
</body>
</html>