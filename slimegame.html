<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slime Care Game | Happy Birthday!</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&family=Pacifico&display=swap" rel="stylesheet">
    <style>
        /* ===== GENERAL STYLES (from original index.html) ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f1a1c2;
            color: #333;
            min-height: 100vh;
            padding-left: 100px;
            text-align: center;
            position: relative;
            overflow-x: hidden;
        }

        /* ===== KUROMI NAVIGATION BAR (from original index.html) ===== */
        .nav-container {
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            width: 100px;
            background-color: #2a0a3a;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 30px;
            z-index: 1000;
            box-shadow: 4px 0 10px rgba(0, 0, 0, 0.2);
            border-right: 3px solid #ff9ec6;
        }

        .nav-item {
            width: 100%;
            text-align: center;
            padding: 15px 0;
            margin: 10px 0;
            color: white;
            font-size: 0.9em;
            text-decoration: none;
            transition: all 0.3s;
        }

        .nav-item:hover {
            background-color: #9b4d96;
            transform: scale(1.05);
        }

        .nav-item img {
            width: 50px;
            height: 50px;
            object-fit: contain;
            margin-bottom: 8px;
        }

        .active {
            background-color: #ff66a3;
            font-weight: bold;
        }

        /* ===== MAIN CONTENT WRAPPER (from original index.html) ===== */
        .page-wrapper {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
        }

        /* ===== HEADER STYLES (from original index.html) ===== */
        header {
            background-color: #9b4d96;
            color: white;
            padding: 20px;
            font-size: 2em;
            text-transform: uppercase;
            font-weight: bold;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        /* ===== MAIN CONTENT STYLES (from original index.html) ===== */
        main {
            width: 100%;
            padding: 40px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 40px;
            position: relative;
            display: flex; /* Added for centering slime game elements */
            flex-direction: column; /* Added for centering slime game elements */
            align-items: center; /* Added for centering slime game elements */
        }

        /* ===== DECORATIVE ELEMENTS (from original index.html) ===== */
        .bow {
            position: absolute;
            width: 40px;
            height: 40px;
            background: url('https://i.imgur.com/tA7aPg4.png') center/contain no-repeat;
            z-index: 10;
        }

        .hearts-container {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }

        .heart {
            position: absolute;
            width: 30px;
            height: 30px;
            color: #f5a9bc;
            font-size: 30px;
            opacity: 0.7;
            animation: floatUp 15s linear infinite;
        }

        @keyframes floatUp {
            0% { transform: translateY(100vh) scale(0.5) rotate(0deg); opacity: 0; }
            10% { opacity: 0.7; }
            90% { opacity: 0.7; }
            100% { transform: translateY(-20vh) scale(1.2) rotate(360deg); opacity: 0; }
        }

        .header-bow-left { top: -15px; left: -15px; }
        .header-bow-right { top: -15px; right: -15px; }
        .main-bow-tl { top: -15px; left: -15px; }
        .main-bow-tr { top: -15px; right: -15px; }
        .main-bow-bl { bottom: -15px; left: -15px; }
        .main-bow-br { bottom: -15px; right: -15px; }

        /* ===== RESPONSIVE STYLES (from original index.html) ===== */
        @media (max-width: 768px) {
            body {
                padding-left: 80px;
            }
            .nav-container {
                width: 80px;
            }
            .nav-item {
                font-size: 0; 
                padding: 15px 0;
            }
            .nav-item img { 
                width: 40px;
                height: 40px;
                margin-bottom: 0;
            }
            .nav-item span { 
                font-size: 24px !important;
            }
            header {
                font-size: 1.8em;
                padding: 15px;
            }
            main {
                padding: 25px;
            }
            #slimeCanvas {
                width: 100% !important; 
                max-width: 350px !important; 
                height: auto !important; 
            }
            .status-bars {
                flex-direction: column;
                width: 90% !important;
                gap: 10px !important;
            }
            .bar-container {
                width: 100% !important; 
            }
            .customization {
                width: 90% !important;
            }
        }

        /* ===== SLIME GAME SPECIFIC STYLES ===== */
        #slimeCanvas {
            border: 3px solid #a0d2eb; 
            background-color: #e0ffff; 
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border-radius: 10px;
            margin-bottom: 20px;
            max-width: 400px;
        }

        .status-bars {
            display: flex;
            gap: 20px; 
            margin-bottom: 20px;
            width: 100%;
            max-width: 380px; 
            justify-content: space-around;
        }

        .status-bar {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 14px;
            font-family: 'Poppins', sans-serif;
        }

        .status-bar label {
            margin-bottom: 5px;
            font-weight: bold;
        }

        .bar-container {
            width: 150px;
            height: 20px;
            background-color: #e0e0e0;
            border: 1px solid #ccc;
            border-radius: 5px;
            overflow: hidden; 
            margin-bottom: 5px;
        }

        .bar-fill {
            height: 100%;
            background-color: #4CAF50; 
            width: 100%; 
            transition: width 0.3s ease-in-out, background-color 0.3s ease-in-out;
        }

        .controls {
            margin-bottom: 15px;
        }

        .controls button { 
            padding: 10px 20px;
            font-size: 1em; 
            font-family: 'Poppins', sans-serif;
            margin: 5px;
            border: none;
            border-radius: 8px; 
            cursor: pointer;
            color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            transition: all 0.2s;
        }

        .controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        #feedButton {
            background-color: #f9a825; 
        }
        #feedButton:hover {
            background-color: #f57f17;
        }

        #playButton {
            background-color: #66bb6a; 
        }
        #playButton:hover {
            background-color: #43a047;
        }

        .customization {
            background-color: #fff8fa; 
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            width: 100%;
            max-width: 380px;
            text-align: center;
        }

        .customization h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #9b4d96; 
            font-family: 'Pacifico', cursive; 
            font-size: 1.5em;
        }

        .customization p {
            margin: 5px 0 8px 0;
            font-weight: bold;
            color: #7c3c79; 
            font-family: 'Poppins', sans-serif;
        }

        .color-picker, .hat-picker {
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .color-picker p, .hat-picker p {
            margin-right: 10px;
        }

        .color-btn {
            width: 30px;
            height: 30px;
            border: 2px solid #ccc;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0;
            transition: transform 0.2s, border-color 0.2s;
        }
        .color-btn:hover {
            transform: scale(1.1);
            border-color: #888;
        }

        .hat-btn {
            padding: 5px 10px;
            font-size: 20px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
        }
        .hat-btn:hover {
            background-color: #e0e0e0;
            transform: scale(1.1);
        }

        #slimeMessage {
            font-size: 1.1em;
            font-family: 'Poppins', sans-serif;
            color: #555;
            min-height: 25px;
            font-style: italic;
            margin-top: 10px;
        }

    </style>
</head>
<body>
 <!-- Navigation -->
    <div class="nav-container">
        <a href="index.html" class="nav-item home">
            <img src="https://i.imgur.com/ZAl2gbp.png" alt="Home">
            Home
        </a>
        <a href="loveletters.html" class="nav-item letters">
            <img src="https://i.imgur.com/ZVhcvD8.png" alt="Love Letters">
            Love Letters
        </a>
        <a href="lovecalculator.html" class="nav-item calculator">
            <img src="https://i.imgur.com/megzmKr.png" alt="Love Calculator">
            Love Calculator
        </a>
        <a href="movies.html" class="nav-item movies">
            <img src="https://i.imgur.com/gzW8uSH.png" alt="Movie Picker">
            Movie Picker
        </a>
        <a href="bookdate.html" class="nav-item bookdate">
            <img src="https://i.imgur.com/megzmKr.png" alt="Book a Date">
            Book a Date
        </a>
        <a href="timezone.html" class="nav-item timezone">
            <img src="https://i.imgur.com/ZwOw9QN.png" alt="Time Bridge">
            Time Bridge
        </a>
        <a href="slimegame.html" class="nav-item slimegame"> 
            <img src="https://i.imgur.com/QY1Y0nC.png" alt="Slime Game Icon">
            Slime Game
        </a>
    </div>

    <div class="page-wrapper">
        <header>
            Slime Pet Care üíñ
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow header-bow-left">
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow header-bow-right">
        </header>

        <main>
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow main-bow-tl">
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow main-bow-tr">
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow main-bow-bl">
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow main-bow-br">
            
            <canvas id="slimeCanvas" width="400" height="300"></canvas>

            <div class="status-bars">
                <div class="status-bar">
                    <label for="hungerBar">Hunger:</label>
                    <div class="bar-container">
                        <div id="hungerBar" class="bar-fill"></div>
                    </div>
                    <span id="hungerValue">100/100</span>
                </div>
                <div class="status-bar">
                    <label for="happinessBar">Happiness:</label>
                    <div class="bar-container">
                        <div id="happinessBar" class="bar-fill"></div>
                    </div>
                    <span id="happinessValue">100/100</span>
                </div>
            </div>

            <div class="controls">
                <button id="feedButton">Feed Slime üçñ</button>
                <button id="playButton">Play with Slime üòä</button>
            </div>

            <div class="customization">
                <h3>Customize Your Slime!</h3>
                <div class="color-picker">
                    <p>Color:</p>
                    <button class="color-btn" data-color="rgba(144, 238, 144, 1)" style="background-color: lightgreen;">Green</button>
                    <button class="color-btn" data-color="rgba(135, 206, 250, 1)" style="background-color: lightskyblue;">Blue</button>
                    <button class="color-btn" data-color="rgba(255, 182, 193, 1)" style="background-color: lightpink;">Pink</button>
                    <button class="color-btn" data-color="rgba(255, 215, 0, 1)" style="background-color: gold;">Gold</button>
                    <button class="color-btn" data-color="rgba(221, 160, 221, 1)" style="background-color: plum;">Plum</button>
                </div>
                <div class="hat-picker">
                    <p>Hat:</p>
                    <button class="hat-btn" data-hat="üëë">üëë</button>
                    <button class="hat-btn" data-hat="üé©">üé©</button>
                    <button class="hat-btn" data-hat="ü•≥">ü•≥</button>
                    <button class="hat-btn" data-hat="‚≠ê">‚≠ê</button>
                    <button class="hat-btn" data-hat="üçì">üçì</button>
                    <button class="hat-btn" data-hat="none">No Hat</button>
                </div>
            </div>
            <p id="slimeMessage">Your slime is content.</p>
        </main>
    </div>

    <div class="hearts-container" id="hearts-container"></div>

    <script>
        function createHearts() {
            const container = document.getElementById('hearts-container');
            if (!container) return;
            const heartCount = container.children.length;
            if (heartCount > 50) return; 
            for (let i = 0; i < 15; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                heart.innerHTML = '‚ù§Ô∏è'; 
                heart.style.left = `${Math.random() * 100}vw`;
                heart.style.animationDuration = `${10 + Math.random() * 10}s`; 
                heart.style.animationDelay = `${Math.random() * 5}s`;
                heart.style.fontSize = `${15 + Math.random() * 15}px`; 
                heart.style.opacity = `${0.5 + Math.random() * 0.4}`; 
                container.appendChild(heart);
                heart.addEventListener('animationend', () => {
                    heart.remove();
                });
            }
        }
        
        function setActiveNav() {
            const navItems = document.querySelectorAll('.nav-container .nav-item');
            let path = window.location.pathname.split("/").pop();
            if (path === "") {
                path = "index.html";
            }
            navItems.forEach(item => {
                item.classList.remove('active');
                if (item.getAttribute('href') === path) {
                    item.classList.add('active');
                }
            });
        }

        // ===== SLIME GAME SCRIPT =====
        const canvas = document.getElementById('slimeCanvas');
        const ctx = canvas.getContext('2d');

        const feedButton = document.getElementById('feedButton');
        const playButton = document.getElementById('playButton');

        const hungerBar = document.getElementById('hungerBar');
        const happinessBar = document.getElementById('happinessBar');
        const hungerValueDisplay = document.getElementById('hungerValue');
        const happinessValueDisplay = document.getElementById('happinessValue');
        const slimeMessage = document.getElementById('slimeMessage');

        const colorButtons = document.querySelectorAll('.color-btn');
        const hatButtons = document.querySelectorAll('.hat-btn');

        const MAX_STAT = 100;
        const STAT_DECAY_RATE = 1;
        const FEED_AMOUNT = 30;
        const PLAY_AMOUNT = 25;
        const TICK_INTERVAL = 2000;

        let slime = {
            hunger: MAX_STAT,
            happiness: MAX_STAT,
            x: canvas.width / 2,
            y: canvas.height - 70, // Ground Y position of the slime's center-bottom
            baseWidth: 90,    // Slightly narrower for a rounder feel
            baseHeight: 70,   // Taller to allow for more roundness
            baseColor: 'rgba(144, 238, 144, 1)', // Default base color (full opacity for gradient base)
            color: 'rgba(144, 238, 144, 1)',    
            hat: null, 
            hatSize: 40, // Slightly larger hat
            eyeColor: 'black',
            pupilColor: 'white',
            eyeOffsetX: 18, // Eyes slightly closer
            eyeOffsetY: -15, // Eyes slightly higher on the rounder head
            eyeRadius: 9,  // Slightly smaller eyes to fit the rounder head
            pupilRadius: 3.5,
            mouthType: 'smile',
            isBouncing: false,
            bounceHeight: 0,
            animationTimer: 0
        };

        // Helper function to parse RGBA string and create a lighter/darker version for gradient
        function getGradientColors(rgbaString) {
            const match = rgbaString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (!match) return [rgbaString, rgbaString]; // Fallback

            let r = parseInt(match[1]);
            let g = parseInt(match[2]);
            let b = parseInt(match[3]);
            let a = match[4] ? parseFloat(match[4]) : 1;

            // Create a slightly lighter color for the top of the gradient
            const lighterR = Math.min(255, r + 30);
            const lighterG = Math.min(255, g + 30);
            const lighterB = Math.min(255, b + 30);

            return [`rgba(${lighterR}, ${lighterG}, ${lighterB}, ${a})`, `rgba(${r}, ${g}, ${b}, ${a})`];
        }


        function drawSlime() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let currentHeight = slime.baseHeight - slime.bounceHeight;
            let currentY = slime.y + slime.bounceHeight / 2; // This is the Y for the bottom center of the slime
            let slimeBodyTopY = currentY - currentHeight;      // Y for the very top of the slime body
            let slimeBodyBottomY = currentY;                   // Y for the very bottom of the slime body

            // Create gradient
            const gradientColors = getGradientColors(slime.color); // Use slime.color for dynamic animation colors too
            const gradient = ctx.createLinearGradient(slime.x, slimeBodyTopY, slime.x, slimeBodyBottomY);
            gradient.addColorStop(0, gradientColors[0]); // Lighter color at the top
            gradient.addColorStop(1, gradientColors[1]); // Base color at the bottom

            ctx.fillStyle = gradient;

            // Rounder body shape
            ctx.beginPath();
            // Start at the bottom middle
            ctx.moveTo(slime.x, slimeBodyBottomY);
            // Left side curve (more rounded bottom)
            ctx.bezierCurveTo(
                slime.x - slime.baseWidth / 1.5, slimeBodyBottomY + 10, // Control point 1 (wider, lower)
                slime.x - slime.baseWidth / 1.8, slimeBodyTopY - 20,    // Control point 2 (wider, much higher for round top)
                slime.x, slimeBodyTopY                               // Endpoint: Top center
            );
            // Right side curve
            ctx.bezierCurveTo(
                slime.x + slime.baseWidth / 1.8, slimeBodyTopY - 20,    // Control point 1
                slime.x + slime.baseWidth / 1.5, slimeBodyBottomY + 10, // Control point 2
                slime.x, slimeBodyBottomY                               // Endpoint: Bottom center (back to start)
            );
            ctx.closePath();
            ctx.fill();


            // Shadow (adjust to be under the new rounder base)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.beginPath();
            ctx.ellipse(slime.x, slimeBodyBottomY + 5, slime.baseWidth / 2.2, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Hat
            if (slime.hat && slime.hat !== 'none') {
                ctx.font = `${slime.hatSize}px 'Arial', 'sans-serif'`; // Generic font stack for better emoji
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle'; // Better vertical alignment for emojis

                // Hat Y position: on top of 'slimeBodyTopY', adjust for hat size and bounce
                let hatYPosition = slimeBodyTopY - (slime.hatSize * 0.35) + (slime.bounceHeight * 0.5);
                // Custom offsets for specific hats if needed
                if (slime.hat === 'üëë') hatYPosition -= 2;
                if (slime.hat === 'üé©') hatYPosition += 2;
                if (slime.hat === 'üçì') hatYPosition -= 3;

                ctx.fillText(slime.hat, slime.x, hatYPosition);
            }

            // Eyes
            // Position eyes relative to the center of the slime's visual mass, which is higher now
            const eyeCenterY = slimeBodyTopY + slime.baseHeight * 0.4 + slime.bounceHeight * 0.1; // Adjusted Y for eyes
            const leftEyeX = slime.x - slime.eyeOffsetX;
            const rightEyeX = slime.x + slime.eyeOffsetX;
            const eyeY = eyeCenterY + slime.eyeOffsetY;


            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(leftEyeX, eyeY, slime.eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(rightEyeX, eyeY, slime.eyeRadius, 0, Math.PI * 2);
            ctx.fill();

            // Pupils
            ctx.fillStyle = slime.eyeColor;
            let pupilOffsetY = 0;
            if (slime.mouthType === 'happy' || slime.mouthType === 'smile') pupilOffsetY = -1; // Smaller offset
            if (slime.mouthType === 'sad') pupilOffsetY = 1;

            ctx.beginPath();
            ctx.arc(leftEyeX, eyeY + pupilOffsetY, slime.pupilRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(rightEyeX, eyeY + pupilOffsetY, slime.pupilRadius, 0, Math.PI * 2);
            ctx.fill();

            // Mouth
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const mouthBaseY = eyeY + slime.eyeRadius + 2; // Closer to eyes
            switch (slime.mouthType) {
                case 'smile':
                case 'happy':
                    ctx.arc(slime.x, mouthBaseY, 8, 0.1 * Math.PI, 0.9 * Math.PI); // Wider smile
                    break;
                case 'ooh':
                    ctx.arc(slime.x, mouthBaseY + 3, 4, 0, Math.PI * 2); // Smaller 'ooh'
                    break;
                case 'sad':
                    ctx.arc(slime.x, mouthBaseY + 8, 8, 1.1 * Math.PI, 1.9 * Math.PI); // Sad mouth
                    break;
                case 'neutral':
                default:
                    ctx.moveTo(slime.x - 8, mouthBaseY + 3);
                    ctx.lineTo(slime.x + 8, mouthBaseY + 3);
                    break;
            }
            ctx.stroke();
        }

        function updateStatusBars() {
            const hungerPercent = (slime.hunger / MAX_STAT) * 100;
            hungerBar.style.width = hungerPercent + '%';
            hungerValueDisplay.textContent = `${Math.round(slime.hunger)}/${MAX_STAT}`;
            if (hungerPercent < 30) hungerBar.style.backgroundColor = '#f44336';
            else if (hungerPercent < 60) hungerBar.style.backgroundColor = '#ffeb3b';
            else hungerBar.style.backgroundColor = '#4CAF50';

            const happinessPercent = (slime.happiness / MAX_STAT) * 100;
            happinessBar.style.width = happinessPercent + '%';
            happinessValueDisplay.textContent = `${Math.round(slime.happiness)}/${MAX_STAT}`;
            if (happinessPercent < 30) happinessBar.style.backgroundColor = '#f44336';
            else if (happinessPercent < 60) happinessBar.style.backgroundColor = '#ffeb3b';
            else happinessBar.style.backgroundColor = '#4CAF50';
        }

        function determineSlimeColorAndExpression() {
             // Use slime.baseColor to derive the current visual color
            let currentVisualColor = slime.baseColor;

            if (slime.hunger < 30 || slime.happiness < 30) {
                slime.mouthType = 'sad';
                // For sadness, make the base color appear more desaturated/dim by modifying its alpha or components for the gradient
                const sadColors = getGradientColors(slime.baseColor.replace(/(\d+)(?=\))/g, (match, p1) => parseFloat(p1) * 0.7)); // Darken components
                currentVisualColor = sadColors[1]; // Use the darker part of a sad gradient as the base for getGradientColors
                setMessage("Your slime looks sad and hungry!");
            } else if (slime.hunger < 60 || slime.happiness < 60) {
                slime.mouthType = 'neutral';
                const neutralColors = getGradientColors(slime.baseColor.replace(/(\d+)(?=\))/g, (match, p1) => parseFloat(p1) * 0.85));
                currentVisualColor = neutralColors[1];
                setMessage("Your slime seems a bit bored or peckish.");
            } else {
                slime.mouthType = 'smile';
                currentVisualColor = slime.baseColor; 
                setMessage("Your slime is content!");
            }
            slime.color = currentVisualColor; // This will be used by getGradientColors in drawSlime
        }

        function updateSlimeState() {
            slime.hunger -= STAT_DECAY_RATE;
            slime.happiness -= STAT_DECAY_RATE;

            slime.hunger = Math.max(0, slime.hunger);
            slime.happiness = Math.max(0, slime.happiness);

            if (slime.animationTimer <= 0) {
                determineSlimeColorAndExpression();
            } else {
                slime.animationTimer--;
                if (slime.animationTimer === 0) {
                    slime.isBouncing = false;
                    slime.bounceHeight = 0;
                    determineSlimeColorAndExpression(); // Revert to base color/expression
                }
            }

            if (slime.isBouncing) {
                slime.bounceHeight = Math.abs(Math.sin(Date.now() * 0.015)) * 12; // Slightly more pronounced bounce
            }

            updateStatusBars();
            drawSlime();
        }

        function feedSlime() {
            if (slime.hunger < MAX_STAT) {
                slime.hunger = Math.min(MAX_STAT, slime.hunger + FEED_AMOUNT);
                slime.happiness = Math.min(MAX_STAT, slime.happiness + PLAY_AMOUNT / 3);
                setMessage("Yum! Slime enjoyed the food!");
                slime.mouthType = 'ooh';
                slime.color = 'rgba(173, 255, 47, 1)'; // Brighter GreenYellow for eating, full opacity for gradient
                slime.animationTimer = 25; // Animation ticks (TICK_INTERVAL based, so 25 * 20ms if TICK_INTERVAL is 20ms)
                                          // If TICK_INTERVAL is 2000ms, then 25 means 50 seconds. Let's use a smaller number.
                slime.animationTimer = Math.round(1.5 * 1000 / (TICK_INTERVAL / 100)); // e.g. 1.5 seconds of animation
                triggerBounce();
            } else {
                setMessage("Slime is already full!");
            }
            updateStatusBars(); 
            drawSlime(); 
        }

        function playWithSlime() {
            if (slime.happiness < MAX_STAT) {
                slime.happiness = Math.min(MAX_STAT, slime.happiness + PLAY_AMOUNT);
                setMessage("Whee! Slime had fun playing!");
                slime.mouthType = 'happy';
                slime.color = 'rgba(135, 206, 250, 1)'; // Brighter LightSkyBlue for play
                slime.animationTimer = Math.round(1.5 * 1000 / (TICK_INTERVAL / 100));
                triggerBounce(true);
            } else {
                setMessage("Slime is perfectly happy right now!");
            }
            updateStatusBars();
            drawSlime();
        }

        function triggerBounce(longer = false) {
            slime.isBouncing = true;
            const duration = longer ? 1500 : 750;
            // Let animationTimer handle bounce stopping if it's active
            if (slime.animationTimer === 0) {
                setTimeout(() => {
                    if (slime.animationTimer <= 0) { // Double check no other animation started
                        slime.isBouncing = false;
                        slime.bounceHeight = 0;
                        drawSlime(); 
                    }
                }, duration);
            }
        }


        function setMessage(msg) {
            slimeMessage.textContent = msg;
        }

        colorButtons.forEach(button => {
            button.addEventListener('click', () => {
                slime.baseColor = button.dataset.color;
                if (slime.animationTimer <= 0) {
                    determineSlimeColorAndExpression();
                }
                drawSlime(); 
            });
        });

        hatButtons.forEach(button => {
            button.addEventListener('click', () => {
                const newHat = button.dataset.hat;
                slime.hat = (newHat === 'none') ? null : newHat;
                drawSlime(); 
            });
        });

        feedButton.addEventListener('click', feedSlime);
        playButton.addEventListener('click', playWithSlime);
        
        let gameIntervalId = null;

        function startGame() {
            // Initial slime properties for rounder look
            slime.x = canvas.width / 2;
            slime.y = canvas.height - slime.baseHeight / 2 - 20; // Adjust Y to be center of mass from bottom

            determineSlimeColorAndExpression(); 
            drawSlime();
            updateStatusBars();
            if(gameIntervalId) clearInterval(gameIntervalId);
            gameIntervalId = setInterval(updateSlimeState, TICK_INTERVAL);
        }

        window.addEventListener('load', () => {
            createHearts(); 
            setInterval(createHearts, 15000); 
            setActiveNav(); 

            if (canvas && feedButton && playButton) { 
                 startGame();
            }
        });
    </script>
</body>
</html>