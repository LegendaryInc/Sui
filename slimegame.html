<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slime Tamagotchi</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&family=Pacifico&display=swap" rel="stylesheet">
    <style>
        /* ===== GENERAL STYLES ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f1a1c2;
            color: #333;
            min-height: 100vh;
            padding-left: 100px;
            text-align: center;
            position: relative;
            overflow-x: hidden;
        }

        /* ===== KUROMI NAVIGATION BAR ===== */
        .nav-container {
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            width: 100px;
            background-color: #2a0a3a;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 30px;
            z-index: 1000;
            box-shadow: 4px 0 10px rgba(0, 0, 0, 0.2);
            border-right: 3px solid #ff9ec6;
        }

        .nav-item {
            width: 100%;
            text-align: center;
            padding: 15px 0;
            margin: 5px 0; /* Adjusted margin */
            color: white;
            font-size: 0.8em; /* Adjusted font size */
            text-decoration: none;
            transition: all 0.3s;
            cursor: pointer; /* Added cursor pointer */
        }

        .nav-item img {
            width: 45px; /* Adjusted image size */
            height: 45px; /* Adjusted image size */
            object-fit: contain;
            margin-bottom: 5px; /* Adjusted margin */
        }

        .nav-item:hover {
            background-color: #9b4d96;
            transform: scale(1.05);
        }

        .active {
            background-color: #ff66a3;
            font-weight: bold;
        }

        /* ===== MAIN CONTENT WRAPPER ===== */
        .page-wrapper {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
        }

        /* ===== HEADER STYLES ===== */
        header {
            background-color: #9b4d96;
            color: white;
            padding: 20px;
            font-size: 2em;
            text-transform: uppercase;
            font-weight: bold;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        /* ===== MAIN CONTENT STYLES ===== */
        main {
            width: 100%;
            padding: 40px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 40px;
            position: relative;
            min-height: 500px; /* Give main a min height */
            display: flex; /* Use flexbox for main content */
            flex-direction: column; /* Arrange content vertically */
            justify-content: center; /* Center content vertically */
            align-items: center; /* Center content horizontally */
        }

        /* Hide all game screens by default */
        .game-screen-container {
            display: none; /* Hide by default */
            width: 100%; /* Take full width of main */
            text-align: center; /* Center content inside */
        }

        /* Make the active screen visible */
        .game-screen-container.active-screen {
            display: block;
        }


        /* ===== TEXT STYLES ===== */
        .celebration-status {
            font-family: 'Pacifico', cursive;
            font-size: 2em;
            color: #e91e63;
            margin: 20px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .birthday-message {
            font-size: 1.5em;
            margin: 20px 0;
            color: #9b4d96;
            font-weight: 600;
        }

        .birthday-submessage {
            font-size: 1.2em;
            margin-bottom: 30px;
            color: #333;
        }

        /* ===== SLIME TAMAGOTCHI STYLES ===== */
        /* Removed slime-game-container, screens are now direct children of main */
        /* Styles for login/create/game/store/inventory screens */
        .login-container, .create-slime-container, .game-screen, .store-screen, .inventory-screen, .minigame-select-screen, .minigame-container {
             max-width: 600px;
             margin: 0 auto;
             padding: 20px;
             background-color: #fff8fa;
             border-radius: 15px;
             box-shadow: 0 5px 15px rgba(0,0,0,0.1);
             border: 3px solid #f5a9bc;
             width: 100%; /* Take full width of parent */
             display: flex; /* Use flex for internal layout */
             flex-direction: column; /* Stack content vertically */
             align-items: center; /* Center horizontally */
        }

        .game-title {
            font-family: 'Pacifico', cursive;
            color: #9b4d96;
            font-size: 1.8em;
            margin-bottom: 20px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.1);
        }

        .login-container, .create-slime-container {
             /* Add specific styles if needed */
        }

        .login-form, .slime-form {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%; /* Ensure forms take available width */
        }

        #username-input, #slime-name-input {
            padding: 12px 20px;
            border: 2px solid #f5a9bc;
            border-radius: 30px;
            font-size: 1.1em;
            width: 100%;
            max-width: 300px; /* Kept max-width for input fields */
            margin-bottom: 15px;
            font-family: 'Poppins', sans-serif;
            text-align: center;
            outline: none;
        }

        #username-input:focus, #slime-name-input:focus {
            border-color: #9b4d96;
            box-shadow: 0 0 8px rgba(155, 77, 150, 0.4);
        }

        .color-picker {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }

        .color-picker span {
            margin-bottom: 10px;
            font-weight: 600;
            color: #9b4d96;
        }

        #slime-color-input {
            width: 80px;
            height: 80px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            overflow: hidden;
        }

        #slime-color-input::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
            padding: 0;
        }

        #slime-color-input::-webkit-color-swatch-wrapper {
            border: none;
            border-radius: 50%;
            padding: 0;
        }

        .login-button, .create-slime-button {
            background-color: #9b4d96;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.2em;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
        }

        .login-button:hover, .create-slime-button:hover {
            background-color: #7c3c79;
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }


        /* Game screen specific adjustments */
        .game-screen {
             justify-content: flex-start; /* Align content to top */
             padding-top: 40px; /* Add padding at top */
        }

         .currency-display {
             font-size: 1.3em;
             font-weight: 600;
             color: #2a0a3a;
             margin-bottom: 20px;
         }

        .slime-container {
            position: relative;
            width: 200px;
            height: 200px;
            margin: 0 auto 20px;
            overflow: hidden; /* Ensure equipped items don't overflow */
            cursor: pointer; /* Add cursor for tapping games */
        }

        .slime {
            width: 100%;
            height: 80%;
            background-color: var(--slime-color, #88ff88);
            border-radius: 50% 50% 40% 40%;
            position: relative;
            animation: slimeBounce 2s infinite alternate ease-in-out;
            z-index: 5; /* Ensure slime is above shadow */
        }

        /* Equipped Item Styles */
        .equipped-item {
             position: absolute;
             object-fit: contain;
             z-index: 6; /* Above slime */
        }

        .equipped-hat {
            width: 80px; /* Adjust size as needed */
            height: 80px; /* Adjust size as needed */
            top: -20px; /* Position above slime head */
            left: calc(50% - 40px); /* Center horizontally */
        }

        .equipped-background {
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 1; /* Behind the slime and shadow */
            /* background-size: cover; /* Or contain */
            /* background-position: center; */
        }
         /* Use img tag for background */
        .equipped-background img {
             width: 100%;
             height: 100%;
             object-fit: cover; /* Or 'contain' depending on desired effect */
             display: block; /* Remove extra space below image */
        }


        .slime::before {
            content: '';
            position: absolute;
            width: 40%;
            height: 35%;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            top: 15%;
            left: 10%;
        }

        .eyes {
            position: absolute;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            top: 40%;
            z-index: 7; /* Above hat if hat covers eyes */
        }

        .eye {
            width: 14px;
            height: 14px;
            background: black;
            border-radius: 50%;
        }

        .mouth {
            position: absolute;
            width: 30px;
            height: 10px;
            background: black;
            border-radius: 25px;
            bottom: 25%;
            left: calc(50% - 15px);
             z-index: 7; /* Above hat */
        }

        [data-mood="happy"] .mouth {
            height: 10px;
            border-radius: 0 0 20px 20px;
            background: transparent;
            border-bottom: 3px solid black;
        }

        [data-mood="hungry"] .mouth {
            height: 10px;
            border-radius: 20px 20px 0 0;
            background: transparent;
            border-top: 3px solid black;
            bottom: 22%;
        }

        [data-mood="tired"] .mouth {
            width: 20px;
            height: 2px;
            background: black;
            left: calc(50% - 10px);
            bottom: 25%;
        }

        [data-mood="sick"] .mouth {
            height: 10px;
            border-radius: 20px 20px 0 0;
            background: transparent;
            border-top: 3px solid black;
            transform: rotate(180deg);
            bottom: 22%;
        }

        @keyframes slimeBounce {
            0% { transform: translateY(0) scale(1, 0.95); }
            100% { transform: translateY(-5px) scale(0.95, 1.05); }
        }

        .slime-shadow {
            width: 80%;
            height: 15px;
            background: rgba(0,0,0,0.1);
            border-radius: 50%;
            position: absolute;
            bottom: 0;
            left: 10%;
            z-index: 4; /* Between background and slime */
        }

        .slime-name {
            font-family: 'Pacifico', cursive;
            font-size: 1.5em;
            color: #9b4d96;
            margin: 10px 0;
        }

        .slime-stats {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
            width: 100%; /* Ensure stats take full width */
        }

        .stat-row {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .stat-label {
            font-weight: 600;
            color: #9b4d96;
            margin-bottom: 5px;
        }

        .stat-bar {
            width: 100%;
            height: 15px;
            background-color: #f1f1f1;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .stat-fill {
            height: 100%;
            background-color: #9b4d96;
            border-radius: 10px;
            transition: width 0.5s;
        }

        .actions {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .action-btn {
            background-color: #f5a9bc;
            color: #2a0a3a;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
        }

        .action-btn:hover {
            background-color: #e91e63;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }

        /* Store/Inventory/Minigame Select Screens */
        .store-screen, .inventory-screen, .minigame-select-screen {
            /* Basic flex layout for screens */
            align-items: flex-start; /* Align items to the start (left) */
            padding-top: 30px;
        }

        .screen-title {
             font-family: 'Pacifico', cursive;
             color: #9b4d96;
             font-size: 1.6em;
             margin-bottom: 20px;
             text-shadow: 1px 1px 3px rgba(0,0,0,0.1);
             width: 100%; /* Title takes full width */
             text-align: center; /* Center the title */
        }

        .store-items-list, .inventory-items-list {
             width: 100%;
             list-style: none; /* Remove list bullets */
             padding: 0;
             margin: 0;
             display: flex;
             flex-wrap: wrap; /* Allow items to wrap */
             gap: 15px; /* Space between items */
             justify-content: center; /* Center items */
        }

        .item-card {
            background-color: #fff0f5;
            border: 2px solid #ffb1cc;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            width: 120px; /* Fixed width for item cards */
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .item-card img {
            width: 60px; /* Size for item icons/previews */
            height: 60px;
            object-fit: contain;
            margin-bottom: 8px;
        }

         /* Placeholder/visual for color items */
        .item-color-preview {
             width: 60px;
             height: 60px;
             border-radius: 50%;
             margin-bottom: 8px;
             border: 1px solid #ccc; /* Add slight border */
        }


        .item-name {
            font-weight: 600;
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #2a0a3a;
        }

        .item-price {
            font-size: 0.8em;
            color: #e91e63;
            margin-bottom: 10px;
        }

        .buy-btn, .equip-btn {
            background-color: #ffb1cc;
            color: #2a0a3a;
            border: none;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
        }

        .buy-btn:hover, .equip-btn:hover {
            background-color: #ff9ec6;
        }

        /* Inventory specific styles */
        .inventory-item-card {
             /* Share styles with item-card but potentially adjust */
             background-color: #ffe6f0; /* Slightly different background */
             border-color: #ffcce0;
        }

        .inventory-item-card .item-quantity {
             font-size: 0.9em;
             color: #9b4d96;
             margin-bottom: 5px;
        }

        .inventory-item-card .equip-btn {
            /* Styles for equip button */
        }

         .item-card .equipped-status {
             font-size: 0.8em;
             font-weight: bold;
             color: green; /* Or another color */
             margin-top: 5px;
         }


        /* Minigame Select Screen */
        .minigame-buttons {
             display: flex;
             flex-direction: column; /* Stack buttons */
             gap: 15px;
             width: 80%; /* Limit width */
             max-width: 300px; /* Max width */
             margin-top: 20px;
        }

        .minigame-select-btn {
             background-color: #9b4d96;
             color: white;
             border: none;
             padding: 12px 30px;
             font-size: 1.2em;
             border-radius: 30px;
             cursor: pointer;
             transition: all 0.3s;
             font-family: 'Poppins', sans-serif;
             font-weight: 600;
        }

         .minigame-select-btn:hover {
             background-color: #7c3c79;
             transform: translateY(-3px);
             box-shadow: 0 4px 8px rgba(0,0,0,0.2);
         }


        /* Individual Minigame Containers */
         .minigame-container {
             position: relative; /* Needed for absolute positioning of game elements */
             overflow: hidden; /* Hide elements outside the container */
             /* Specific dimensions for minigames */
             width: 100%;
             height: 400px; /* Fixed height for minigame area */
             background-color: #e6f7ff; /* Light blue background for game area */
             border: 3px solid #a9d8ff;
         }

        .minigame-info {
             position: absolute;
             top: 10px;
             left: 10px;
             text-align: left;
             font-size: 1.1em;
             font-weight: 600;
             color: #2a0a3a;
             z-index: 20; /* Above game elements */
        }

         .minigame-score { margin-bottom: 5px; }

         .minigame-timer { color: #e91e63; }

         .minigame-message {
             position: absolute;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             font-size: 2em;
             font-family: 'Pacifico', cursive;
             color: #9b4d96;
             text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
             z-index: 25; /* Above everything */
             display: none; /* Hidden initially */
         }


         /* Minigame Specific Elements */

         /* Bubble Pop / Falling Food */
         .minigame-target {
             position: absolute;
             width: 40px; /* Size of bubbles/food */
             height: 40px;
             object-fit: contain;
             cursor: pointer;
             z-index: 10; /* Above background, below info/message */
         }

         .minigame-target.food {
             /* Specific food icon/style */
             background: url('https://i.imgur.com/ExampleFood.png') center/contain no-repeat; /* Replace with actual food URL */
         }
         .minigame-target.bubble {
             /* Specific bubble icon/style */
              width: 30px;
              height: 30px;
              background-color: rgba(155, 77, 150, 0.5); /* Semi-transparent purple */
              border-radius: 50%;
              border: 2px solid rgba(255,255,255,0.8);
              box-shadow: inset 5px 5px 10px rgba(255,255,255,0.3);
              /* Add simple bubble float animation */
              animation: bubbleFloat linear infinite; /* Name, duration, timing, iteration */
              animation-duration: 8s; /* Example duration */
         }

         @keyframes bubbleFloat {
             0% { transform: translateY(100%); }
             100% { transform: translateY(-10%); } /* Float upwards */
         }


         /* Game End/Results */
         .minigame-results {
              margin-top: 20px;
              font-size: 1.3em;
              color: #2a0a3a;
              display: none; /* Hidden initially */
         }

         .minigame-results p { margin-bottom: 10px; }

         .minigame-back-btn {
             margin-top: 20px;
             background-color: #f5a9bc;
             color: #2a0a3a;
             border: none;
             padding: 10px 20px;
             border-radius: 20px;
             font-size: 1em;
             cursor: pointer;
             transition: all 0.3s;
             font-family: 'Poppins', sans-serif;
             font-weight: 600;
         }

         .minigame-back-btn:hover {
             background-color: #e91e63;
             color: white;
         }



        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 2000;
            display: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(155, 77, 150, 0.2);
            border-radius: 50%;
            border-top-color: #9b4d96;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 15px;
            color: #9b4d96;
            font-weight: 600;
        }

        /* ===== DECORATIVE ELEMENTS ===== */
        .bow {
            position: absolute;
            width: 40px;
            height: 40px;
            background: url('https://i.imgur.com/tA7aPg4.png') center/contain no-repeat;
            z-index: 10;
        }

        .hearts-container {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }

        .heart {
            position: absolute;
            width: 30px;
            height: 30px;
            color: #f5a9bc;
            font-size: 30px;
            opacity: 0.7;
            animation: floatUp 15s linear infinite;
        }

        @keyframes floatUp {
            0% { transform: translateY(100vh) scale(0.5) rotate(0deg); opacity: 0; }
            10% { opacity: 0.7; }
            90% { opacity: 0.7; }
            100% { transform: translateY(-20vh) scale(1.2) rotate(360deg); opacity: 0; }
        }

        /* ===== POSITIONING FOR BOWS ===== */
        .header-bow-left { top: -15px; left: -15px; }
        .header-bow-right { top: -15px; right: -15px; }
        .main-bow-tl { top: -15px; left: -15px; }
        .main-bow-tr { top: -15px; right: -15px; }
        .main-bow-bl { bottom: -15px; left: -15px; }
        .main-bow-br { bottom: -15px; right: -15px; }

        /* ===== RESPONSIVE STYLES ===== */
        @media (max-width: 768px) {
            body {
                padding-left: 80px;
            }
            .nav-container {
                width: 80px;
            }
            .nav-item {
                font-size: 0.7em; /* Further adjusted for smaller screens */
                padding: 10px 0; /* Adjusted padding */
                margin: 3px 0; /* Adjusted margin */
            }
             .nav-item img {
                width: 35px; /* Adjusted image size */
                height: 35px; /* Adjusted image size */
                margin-bottom: 3px; /* Adjusted margin */
            }

            header {
                font-size: 1.5em; /* Adjusted size */
                padding: 12px;
            }
            main {
                padding: 20px;
                min-height: 400px; /* Adjusted min height */
            }

            .game-screen-container, .login-container, .create-slime-container, .store-screen, .inventory-screen, .minigame-select-screen, .minigame-container {
                padding: 15px; /* Adjusted padding */
            }

            .game-title {
                font-size: 1.5em; /* Adjusted size */
            }

            #username-input, #slime-name-input {
                 max-width: 250px; /* Adjusted max-width */
                 padding: 10px 15px; /* Adjusted padding */
                 font-size: 1em; /* Adjusted size */
            }

            .login-button, .create-slime-button, .minigame-select-btn {
                padding: 10px 20px;
                font-size: 1em;
            }

             .currency-display {
                font-size: 1.1em; /* Adjusted size */
             }

            .slime-container {
                width: 150px; /* Adjusted size */
                height: 150px; /* Adjusted size */
            }

             .slime {
                /* Adjust slime relative size if needed */
             }

             .equipped-hat {
                 width: 60px; /* Adjusted size */
                 height: 60px;
                 top: -15px;
                 left: calc(50% - 30px);
             }
             .equipped-background {
                /* Adjust as needed */
             }


            .slime-name {
                font-size: 1.2em;
            }
             .slime-stats {
                 margin: 15px 0;
             }
             .stat-label {
                 font-size: 0.9em;
             }

            .actions {
                flex-direction: row; /* Keep row layout for actions if space allows */
                justify-content: center;
                gap: 8px; /* Smaller gap */
                 margin-top: 15px;
            }
             .action-btn {
                 padding: 8px 15px;
                 font-size: 0.9em;
             }

            .store-items-list, .inventory-items-list {
                 gap: 10px; /* Smaller gap */
            }

            .item-card {
                width: 100px; /* Adjusted size */
                padding: 8px;
            }
            .item-card img, .item-color-preview {
                width: 50px; /* Adjusted size */
                height: 50px;
            }
             .item-name, .item-quantity {
                font-size: 0.8em; /* Adjusted size */
             }
             .item-price {
                font-size: 0.7em; /* Adjusted size */
             }
             .buy-btn, .equip-btn {
                 padding: 4px 8px;
                 font-size: 0.7em;
             }

             .minigame-container {
                 height: 300px; /* Adjusted height */
             }

             .minigame-info {
                 font-size: 0.9em; /* Adjusted size */
             }

             .minigame-message {
                 font-size: 1.5em; /* Adjusted size */
             }

             .minigame-target {
                 width: 30px; /* Adjusted size */
                 height: 30px;
             }

             .minigame-back-btn {
                 padding: 8px 15px;
                 font-size: 0.9em;
             }

        }
    </style>
</head>
<body>
    <!-- Loading overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text" id="loading-text">Loading...</div>
    </div>

    <!-- Floating Hearts -->
    <div class="hearts-container" id="hearts-container"></div>

    <!-- Navigation -->
    <div class="nav-container">
        <!-- Renamed to home-nav, etc. for clarity in JS handling -->
        <div class="nav-item" id="home-nav">
            <img src="https://i.imgur.com/ZAl2gbp.png" alt="Home">
            Home
        </div>
        <!-- Add new nav items for Store, Inventory, Minigames -->
        <div class="nav-item" id="store-nav">
             <img src="https://i.imgur.com/StoreIcon.png" alt="Store"> <!-- Replace with actual store icon -->
             Store
        </div>
        <div class="nav-item" id="inventory-nav">
             <img src="https://i.imgur.com/InventoryIcon.png" alt="Inventory"> <!-- Replace with actual inventory icon -->
             Inventory
        </div>
         <div class="nav-item" id="minigames-nav">
             <img src="https://i.imgur.com/MinigameIcon.png" alt="Minigames"> <!-- Replace with actual minigame icon -->
             Minigames
        </div>

        <!-- Existing placeholder nav items (remove if not part of this game) -->
        <!-- Leaving them commented out for now -->
        <!--
        <a href="loveletters.html" class="nav-item letters">
            <img src="https://i.imgur.com/ZVhcvD8.png" alt="Love Letters">
            Love Letters
        </a>
        <a href="lovecalculator.html" class="nav-item calculator">
            <img src="https://i.imgur.com/megzmKr.png" alt="Love Calculator">
            Love Calculator
        </a>
        <a href="movies.html" class="nav-item movies">
            <img src="https://i.imgur.com/gzW8uSH.png" alt="Movie Picker">
            Movie Picker
        </a>
        <a href="bookdate.html" class="nav-item bookdate">
            <img src="https://i.imgur.com/megzmKr.png" alt="Book a Date">
            Book a Date
        </a>
        <a href="timezone.html" class="nav-item timezone">
            <img src="https://i.imgur.com/ZwOw9QN.png" alt="Time Bridge">
            Time Bridge
        </a>
        -->
    </div>

    <div class="page-wrapper">
        <header>
            Slime Tamagotchi 🌟
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow header-bow-left">
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow header-bow-right">
        </header>

        <main>
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow main-bow-tl">
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow main-bow-tr">
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow main-bow-bl">
            <img src="https://i.imgur.com/tA7aPg4.png" class="bow main-bow-br">

            <!-- --- Game Screens Container --- -->
            <!-- All main game screens live inside here -->

            <!-- Login screen -->
            <div class="game-screen-container" id="login-screen">
                <div class="login-container">
                    <h2 class="game-title">Welcome to Slime Tamagotchi!</h2>
                    <p>Enter your name to start caring for your virtual slime pet</p>
                    <div class="login-form">
                        <input type="text" id="username-input" placeholder="Your Name">
                        <button class="login-button" id="login-button">Start Game</button>
                    </div>
                </div>
            </div>

            <!-- Create slime screen -->
            <div class="game-screen-container" id="create-slime-screen">
                 <div class="create-slime-container">
                    <h2 class="game-title">Create Your Slime Friend!</h2>
                    <p>Give your slime a name and choose its color</p>
                    <div class="slime-form">
                        <input type="text" id="slime-name-input" placeholder="Name your slime">
                        <div class="color-picker">
                            <span>Choose a color:</span>
                            <input type="color" id="slime-color-input" value="#88ff88">
                        </div>
                        <button class="create-slime-button" id="create-slime-button">Create Slime</button>
                    </div>
                 </div>
            </div>

            <!-- Main Game screen -->
            <div class="game-screen-container" id="game-screen">
                <div class="game-screen">
                     <div class="currency-display" id="currency-display">Coins: 0</div> <!-- Currency Display -->
                    <h2 class="game-title" id="game-slime-name">Your Slime Pet</h2>

                    <!-- Slime display -->
                    <div class="slime-container" id="main-slime-container">
                        <!-- Equipped Background goes here -->
                        <div class="equipped-background" id="equipped-background"></div>
                        <div class="slime" id="slime" data-mood="happy">
                             <!-- Equipped Hat goes here -->
                             <img src="" class="equipped-item equipped-hat" id="equipped-hat" style="display: none;">
                            <div class="eyes">
                                <div class="eye"></div>
                                <div class="eye"></div>
                            </div>
                            <div class="mouth"></div>
                        </div>
                        <div class="slime-shadow"></div>
                    </div>

                    <div class="slime-name" id="slime-name-display">Gooey</div> <!-- Updated ID -->

                    <!-- Stats display -->
                    <div class="slime-stats">
                        <div class="stat-row">
                            <span class="stat-label">Hunger</span>
                            <div class="stat-bar">
                                <div class="stat-fill" id="hunger-fill" style="width: 100%;"></div>
                            </div>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Happiness</span>
                            <div class="stat-bar">
                                <div class="stat-fill" id="happiness-fill" style="width: 100%;"></div>
                            </div>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Health</span>
                            <div class="stat-bar">
                                <div class="stat-fill" id="health-fill" style="width: 100%;"></div>
                            </div>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Energy</span>
                            <div class="stat-bar">
                                <div class="stat-fill" id="energy-fill" style="width: 100%;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Actions -->
                    <div class="actions">
                        <button class="action-btn" id="feed-btn">Feed 🍎</button>
                        <button class="action-btn" id="play-btn">Play 🎾</button>
                        <button class="action-btn" id="clean-btn">Clean 🧼</button>
                        <button class="action-btn" id="sleep-btn">Sleep 😴</button>
                    </div>
                </div>
            </div>

            <!-- Store screen -->
            <div class="game-screen-container" id="store-screen">
                 <div class="store-screen">
                    <h2 class="screen-title">Slime Shop</h2>
                     <div class="currency-display" id="store-currency-display">Coins: 0</div> <!-- Currency Display for Store -->
                    <ul class="store-items-list" id="store-items-list">
                        <!-- Store items will be loaded and displayed here by JavaScript -->
                        <li>Loading store items...</li>
                    </ul>
                 </div>
            </div>

            <!-- Inventory screen -->
            <div class="game-screen-container" id="inventory-screen">
                 <div class="inventory-screen">
                     <h2 class="screen-title">My Inventory</h2>
                     <div class="currency-display" id="inventory-currency-display">Coins: 0</div> <!-- Currency Display for Inventory -->
                     <ul class="inventory-items-list" id="inventory-items-list">
                        <!-- Player inventory items will be loaded and displayed here by JavaScript -->
                         <li>Loading inventory...</li>
                     </ul>
                 </div>
            </div>

             <!-- Minigame Select screen -->
            <div class="game-screen-container" id="minigame-select-screen">
                 <div class="minigame-select-screen">
                     <h2 class="screen-title">Play Minigames</h2>
                     <p>Earn coins by playing fun games with your slime!</p>
                     <div class="minigame-buttons">
                         <button class="minigame-select-btn" data-game="tapper">Slime Tapper</button>
                         <button class="minigame-select-btn" data-game="bubble">Slime Bubble Pop</button>
                         <button class="minigame-select-btn" data-game="feed">Feed The Slime</button>
                     </div>
                 </div>
            </div>

             <!-- Minigame containers -->
             <!-- Each minigame has its own container, shown one at a time -->

            <!-- Slime Tapper Minigame -->
             <div class="game-screen-container" id="minigame-tapper-screen">
                 <div class="minigame-container">
                     <h2 class="screen-title">Slime Tapper!</h2>
                     <div class="minigame-info">
                         <p class="minigame-timer" id="tapper-timer">Time: 0</p>
                         <p class="minigame-score" id="tapper-score">Taps: 0</p>
                     </div>
                      <!-- Slime area (can reuse main slime container visual styles) -->
                     <div class="slime-container" id="tapper-slime-area">
                         <div class="slime" data-mood="happy">
                             <div class="eyes"><div class="eye"></div><div class="eye"></div></div>
                             <div class="mouth"></div>
                         </div>
                         <div class="slime-shadow"></div>
                     </div>
                     <p class="minigame-message" id="tapper-message"></p>
                     <div class="minigame-results" id="tapper-results">
                         <p id="tapper-final-score"></p>
                         <p id="tapper-coins-earned"></p>
                         <button class="minigame-back-btn" data-target="minigame-select-screen">Back to Games</button>
                     </div>
                 </div>
             </div>

             <!-- Slime Bubble Pop Minigame -->
            <div class="game-screen-container" id="minigame-bubble-screen">
                 <div class="minigame-container" id="bubble-game-area">
                     <h2 class="screen-title">Bubble Pop!</h2>
                      <div class="minigame-info">
                         <p class="minigame-timer" id="bubble-timer">Time: 0</p>
                         <p class="minigame-score" id="bubble-score">Popped: 0</p>
                     </div>
                     <!-- Bubbles will be added here by JS -->
                      <p class="minigame-message" id="bubble-message"></p>
                      <div class="minigame-results" id="bubble-results">
                         <p id="bubble-final-score"></p>
                         <p id="bubble-coins-earned"></p>
                         <button class="minigame-back-btn" data-target="minigame-select-screen">Back to Games</button>
                     </div>
                 </div>
             </div>

             <!-- Feed The Slime Minigame -->
             <div class="game-screen-container" id="minigame-feed-screen">
                 <div class="minigame-container" id="feed-game-area">
                     <h2 class="screen-title">Feed The Slime!</h2>
                      <div class="minigame-info">
                         <p class="minigame-timer" id="feed-timer">Time: 0</p>
                         <p class="minigame-score" id="feed-score">Fed: 0</p>
                     </div>
                     <!-- Slime area (can reuse visual styles) -->
                      <div class="slime-container" style="position: relative; margin: 0 auto; pointer-events: none;"> <!-- Disable clicking slime itself -->
                          <div class="slime" data-mood="happy">
                             <div class="eyes"><div class="eye"></div><div class="eye"></div></div>
                             <div class="mouth"></div>
                         </div>
                         <div class="slime-shadow"></div>
                      </div>
                     <!-- Food targets will appear here by JS -->
                     <p class="minigame-message" id="feed-message"></p>
                     <div class="minigame-results" id="feed-results">
                         <p id="feed-final-score"></p>
                         <p id="feed-coins-earned"></p>
                         <button class="minigame-back-btn" data-target="minigame-select-screen">Back to Games</button>
                     </div>
                 </div>
             </div>


        </main>
    </div>

<script>
    // API Configuration
    const API_URL = 'https://script.google.com/macros/s/AKfycbz07jJhC5CACJ1XBhvXU-aAz9Yjf4S5Ds_f1J8iKC9b991fCDk8L-samJbEnrKyNypk8A/exec';
    console.log("INITIALIZING SLIME GAME. API URL:", API_URL);

    // --- Game State Variables ---
    let playerData = { playerId: null, username: null, currency: 0 };
    let slimeData = null;
    let inventoryData = [];
    let storeItems = [];
    let gameInterval;
    const TICK_RATE = 60000; // milliseconds for visual decay tick (1 minute)
    const STAT_DECREASE_RATE_PER_MINUTE = 2; // How much stats decrease per minute visually

    let minigameState = { activeGame: null, timer: null, timeLeft: 0, score: 0, gameElements: [] };
    const MINIGAME_DURATION = 30; // Seconds

    // --- Utility Functions ---
    async function fetchData(action, method = 'GET', data = null) {
        showLoadingIndicator(`Calling: ${action}...`);
        
        // Construct the base URL for the request
        const url = new URL(API_URL); // Always start with the base API_URL

        // Action is always added as a query parameter for both GET and POST
        // because Google Apps Script web apps often expect 'action' in the query for routing.
        url.searchParams.append('action', action);

        // For GET requests, append other data properties as URL parameters
        if (method === 'GET') {
            if (data) {
                for (const key in data) {
                    if (data.hasOwnProperty(key)) {
                        url.searchParams.append(key, data[key]);
                    }
                }
            }
            // Add playerId if it's a GET request that needs it and wasn't already in 'data'
            // (e.g., for getStoreItems, getPlayerInventory)
            if (playerData.playerId && action !== 'createAccount' && action !== 'loadPlayer' && !(data && data.playerId)) {
                 url.searchParams.append('playerId', playerData.playerId);
            }
        }
        
        const targetUrl = url.toString();

        const options = {
            method: method,
            // Conditionally set headers: Only add Content-Type for POST requests
            headers: method === 'POST' ? { 'Content-Type': 'application/json' } : {},
            // For POST, action is typically in the body along with other data.
            // The Apps Script doPost is designed to parse {action: "...", data: {...}} from the body.
            body: (method === 'POST' && data) ? JSON.stringify({ action: action, data: data }) : null,
        };

        console.log(`Fetching: ${method} ${targetUrl}`, method === 'POST' ? options.body : '');

        try {
            const response = await fetch(targetUrl, options);
            if (!response.ok) {
                 const errorBody = await response.text();
                 console.error(`HTTP error! Status: ${response.status} for ${action}`, errorBody, response);
                 throw new Error(`Server error: ${response.status}. Action: ${action}. See console.`);
            }
            const result = await response.json();
            console.log('API Response for action:', action, result);

            if (result.success) {
                // Update currency if the response includes it
                if (result.data && result.data.newCurrency !== undefined) {
                     playerData.currency = result.data.newCurrency;
                 } else if (action === 'loadPlayer' && result.data && result.data.currency !== undefined) {
                      playerData.currency = result.data.currency;
                 } else if (action === 'createAccount') {
                     // createAccount (now GET) returns player object or just currency
                     if (result.data && result.data.player && result.data.player.currency !== undefined) {
                          playerData.currency = result.data.player.currency;
                     } else if (result.data && result.data.currency !== undefined){
                          playerData.currency = result.data.currency;
                     }
                 }
                updateCurrencyDisplay(); // Always update display after potential currency change
                return result.data;
            } else {
                console.error('API Reported Error for action:', action, result.message, result.data ? result.data.details : '');
                alert('API Error: ' + result.message);
                return null;
            }
        } catch (error) {
            console.error('Fetch Exception for action:', action, error);
            alert('Network or Script Execution Failed. Check console.');
            return null;
        } finally {
            hideLoadingIndicator();
        }
    }

    function showLoadingIndicator(message) {
        const loadingTextEl = document.getElementById('loading-text');
        const loadingOverlayEl = document.getElementById('loading-overlay');
        if (loadingTextEl) loadingTextEl.textContent = message || 'Loading...';
        if (loadingOverlayEl) loadingOverlayEl.style.display = 'flex';
    }

    function hideLoadingIndicator() {
        const loadingOverlayEl = document.getElementById('loading-overlay');
        if (loadingOverlayEl) loadingOverlayEl.style.display = 'none';
    }

    // --- Screen Management ---
    function showScreen(screenId) {
        document.querySelectorAll('.game-screen-container').forEach(s => s.classList.remove('active-screen'));
        const target = document.getElementById(screenId);
        if (target) {
            target.classList.add('active-screen');
        } else {
            console.error("Screen not found:", screenId);
            // Fallback to login if a screen is missing, to prevent being stuck
            const loginScreen = document.getElementById('login-screen');
            if(loginScreen) loginScreen.classList.add('active-screen');
        }

        document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
        let activeNavId = null;
        if (screenId === 'game-screen') activeNavId = 'home-nav';
        else if (screenId === 'store-screen') activeNavId = 'store-nav';
        else if (screenId === 'inventory-screen') activeNavId = 'inventory-nav';
        else if (screenId === 'minigame-select-screen' || (screenId.startsWith('minigame-') && screenId.endsWith('-screen'))) activeNavId = 'minigames-nav';
        
        if(activeNavId) { const el = document.getElementById(activeNavId); if(el) el.classList.add('active'); }
        
        if (minigameState.activeGame && !screenId.startsWith('minigame-')) {
            endCurrentMinigame(false); 
        }
    }

    // --- Core Game Functions ---
    async function initializeGame() {
        createHearts(); 
        setActiveNav();
        const savedUsername = localStorage.getItem('slimeGame_username');

        if (savedUsername) {
            const data = await fetchData('loadPlayer', 'GET', { playerName: savedUsername });
            if (data && data.player) {
                playerData = data.player; 
                slimeData = data.slime; 
                inventoryData = data.inventory || [];
                // Currency is updated by fetchData
                localStorage.setItem('slimeGame_playerId', playerData.playerId);
                localStorage.setItem('slimeGame_username', playerData.username);

                if (slimeData) { 
                    showScreen('game-screen'); 
                    // Fetch store items if not already fetched, for equipped item display
                    if (storeItems.length === 0) await fetchStoreItemsOnce();
                    startGameLoop(); 
                } else { 
                    showScreen('create-slime-screen'); 
                }
            } else {
                console.warn("Player data not found on backend. Starting fresh.");
                localStorage.removeItem('slimeGame_username'); localStorage.removeItem('slimeGame_playerId');
                playerData = { playerId: null, username: null, currency: 0 }; slimeData = null; inventoryData = [];
                showScreen('login-screen');
            }
        } else { 
            showScreen('login-screen'); 
        }
    }

    async function handleLogin() {
        const username = document.getElementById('username-input').value.trim();
        if (!username) { alert('Please enter your name'); return; }

        // createAccount is now GET, username is passed in the 'data' object for fetchData
        const accData = await fetchData('createAccount', 'GET', { username: username }); 

        if (accData && accData.playerId) {
            // The script's handleCreateAccount returns player info and message.
            // Store what's returned.
            playerData.playerId = accData.playerId;
            playerData.username = accData.username;
            // If script returns currency for new/existing user with createAccount, it's handled by fetchData

            localStorage.setItem('slimeGame_playerId', playerData.playerId);
            localStorage.setItem('slimeGame_username', playerData.username);

            // Now load full player data (which includes slime, inventory, and definitive currency)
            const loadData = await fetchData('loadPlayer', 'GET', { playerName: playerData.username });
            if(loadData && loadData.player) {
                 playerData = loadData.player; 
                 slimeData = loadData.slime; 
                 inventoryData = loadData.inventory || [];
                 // Currency updated by fetchData

                 // Fetch store items if not already fetched
                 if (storeItems.length === 0) await fetchStoreItemsOnce();

                 if (slimeData) { 
                     showScreen('game-screen'); 
                     startGameLoop(); 
                 } else { 
                     showScreen('create-slime-screen'); 
                 }
            } else {
                 alert('Failed to load full player data after login/creation.');
                 localStorage.removeItem('slimeGame_username'); localStorage.removeItem('slimeGame_playerId');
                 playerData = { playerId: null, username: null, currency: 0 }; slimeData = null; inventoryData = [];
                 showScreen('login-screen');
            }
        }
        // If accData is null, error already alerted by fetchData
    }

    async function handleCreateSlime() {
        const slimeName = document.getElementById('slime-name-input').value.trim();
        const slimeColor = document.getElementById('slime-color-input').value;
        if (!slimeName) { alert('Please name your slime'); return; }
        if (!playerData.playerId) { alert('Player not logged in.'); initializeGame(); return; }

        const newSlime = await fetchData('createSlime', 'POST', { 
            playerId: playerData.playerId, 
            slimeName: slimeName, 
            slimeColor: slimeColor 
        });

        if (newSlime && newSlime.slimeId) { 
            slimeData = newSlime; 
            // Ensure store items are loaded for displaying equipped items (even if default)
            if (storeItems.length === 0) await fetchStoreItemsOnce();
            showScreen('game-screen'); 
            startGameLoop(); 
        }
    }
    
    // Helper to fetch store items once if needed (e.g., for equipped item display)
    async function fetchStoreItemsOnce() {
        if (storeItems.length > 0) return; // Already fetched
        console.log("Fetching store items for the first time...");
        const items = await fetchData('getStoreItems', 'GET');
        if (items) {
            storeItems = items;
        } else {
            console.error("Failed to fetch store items during initial load/check.");
            // Potentially alert user or handle this, but for now, just log
        }
    }

    function updateSlimeDisplay() { /* ... same as your previous correct version ... */ 
        const mainSlimeContainer = document.getElementById('main-slime-container');
        const slimeNameDisplay = document.getElementById('slime-name-display');
        const slimeStatsElement = document.querySelector('.slime-stats');
        const actionsElement = document.querySelector('.actions');

        if (!slimeData) {
            if(mainSlimeContainer) mainSlimeContainer.style.display = 'none'; 
            if(slimeNameDisplay) slimeNameDisplay.textContent = 'No Slime Active'; 
            if(slimeStatsElement) slimeStatsElement.style.display = 'none'; 
            if(actionsElement) actionsElement.style.display = 'none';
            return;
        }
        if(mainSlimeContainer) mainSlimeContainer.style.display = 'block';
        if(slimeStatsElement) slimeStatsElement.style.display = 'flex'; 
        if(actionsElement) actionsElement.style.display = 'flex';
        if(slimeNameDisplay) slimeNameDisplay.textContent = slimeData.name;
        
        const slimeElement = document.getElementById('slime');
        if(slimeElement) slimeElement.style.setProperty('--slime-color', slimeData.color);

        ['hunger', 'happiness', 'health', 'energy'].forEach(s => { 
            const fillEl = document.getElementById(`${s}-fill`);
            if(fillEl) fillEl.style.width = `${Math.max(0, Math.min(100, slimeData[s]))}%`; 
        });
        let mood = 'happy';
        if (slimeData.hunger < 30) mood = 'hungry'; 
        else if (slimeData.energy < 30) mood = 'tired'; 
        else if (slimeData.health < 30) mood = 'sick'; 
        else if (slimeData.happiness < 30) mood = 'sad';
        if(slimeElement) slimeElement.dataset.mood = mood;

        [{ e: 'hunger-fill', v: slimeData.hunger }, { e: 'happiness-fill', v: slimeData.happiness }, { e: 'health-fill', v: slimeData.health }, { e: 'energy-fill', v: slimeData.energy }].forEach(s => {
            const el = document.getElementById(s.e);
            if(el) {
                if (s.v < 30) el.style.backgroundColor = '#ff5252'; 
                else if (s.v < 70) el.style.backgroundColor = '#ffb142'; 
                else el.style.backgroundColor = '#9b4d96';
            }
        });
        updateEquippedItemsDisplay();
    }

    function updateEquippedItemsDisplay() { /* ... same as your previous correct version ... */ 
        const hatEl = document.getElementById('equipped-hat'); 
        const bgEl = document.getElementById('equipped-background');
        if (!slimeData || !hatEl || !bgEl) { return; }
        if (storeItems.length === 0 && (slimeData.hat || slimeData.background)) { 
            console.warn("Store items not loaded; equipped item display might be incomplete. Attempting to fetch.");
            fetchStoreItemsOnce().then(() => updateEquippedItemsDisplay()); // Retry after fetching
            return;
        }
        const hatDet = storeItems.find(i => i.itemId === slimeData.hat && i.itemType === 'Hat');
        const bgDet = storeItems.find(i => i.itemId === slimeData.background && i.itemType === 'Background');
        if (hatDet && hatDet.dataValue) { hatEl.src = hatDet.dataValue; hatEl.style.display = 'block'; } else { hatEl.src = ''; hatEl.style.display = 'none'; }
        if (bgDet && bgDet.dataValue) { bgEl.innerHTML = ''; const img = document.createElement('img'); img.src = bgDet.dataValue; img.alt = 'Background'; bgEl.appendChild(img); bgEl.style.display = 'block'; } else { bgEl.innerHTML = ''; bgEl.style.display = 'none'; }
    }

    async function saveSlimeData() { /* ... same as your previous correct version ... */ 
        if (!slimeData || !playerData.playerId) { console.warn("Cannot save: no slime/player."); return null; }
        const updates = { name: slimeData.name, type: slimeData.type, color: slimeData.color, age: slimeData.age, evolutionStage: slimeData.evolutionStage, hunger: slimeData.hunger, happiness: slimeData.happiness, health: slimeData.health, energy: slimeData.energy, intelligence: slimeData.intelligence, strength: slimeData.strength, agility: slimeData.agility, lastCared: new Date().toISOString(), hat: slimeData.hat, background: slimeData.background };
        slimeData.lastCared = updates.lastCared; // Update local immediately
        const result = await fetchData('updateSlime', 'POST', { slimeId: slimeData.slimeId, updates: updates });
        if (result) { console.log("Slime data saved."); return true; } else { console.error("Failed to save slime data."); return false; }
    }

    function startGameLoop() { /* ... same as your previous correct version ... */ 
        if (gameInterval) clearInterval(gameInterval);
        updateSlimeDisplay(); 
        updateCurrencyDisplay();
        gameInterval = setInterval(() => { 
            calculateAndApplyVisualDecay(); // Changed name for clarity
            saveSlimeData(); // Periodic save
        }, TICK_RATE);
    }

    function calculateAndApplyVisualDecay() { /* Renamed for clarity */
        if (!slimeData) return;
        const decayAmount = STAT_DECREASE_RATE_PER_MINUTE * (TICK_RATE / 60000);
        slimeData.hunger = Math.max(0, slimeData.hunger - decayAmount);
        slimeData.happiness = Math.max(0, slimeData.happiness - decayAmount);
        slimeData.energy = Math.max(0, slimeData.energy - decayAmount);
        if (slimeData.hunger < 30 || slimeData.happiness < 30) { 
            slimeData.health = Math.max(0, slimeData.health - (decayAmount * 0.5));
        }
        updateSlimeDisplay(); // Update visuals after decay
    }

    async function performCareAction(actionType, statIncreases, currencyAmount) { /* ... same as your previous correct version ... */ 
        if (!slimeData || !playerData.playerId) { alert("Please log in/create slime."); initializeGame(); return; }
        calculateAndApplyVisualDecay(); // Apply any decay before the action
        if (statIncreases.hunger !== undefined) slimeData.hunger = Math.min(100, slimeData.hunger + statIncreases.hunger);
        if (statIncreases.happiness !== undefined) slimeData.happiness = Math.min(100, slimeData.happiness + statIncreases.happiness);
        if (statIncreases.health !== undefined) slimeData.health = Math.min(100, slimeData.health + statIncreases.health);
        if (statIncreases.energy !== undefined) slimeData.energy = Math.min(100, slimeData.energy + statIncreases.energy);
        updateSlimeDisplay();
        const saveSuccess = await saveSlimeData();
        if (saveSuccess && currencyAmount > 0) {
            const currencyResult = await fetchData('earnCurrency', 'POST', { playerId: playerData.playerId, amount: currencyAmount });
            if (currencyResult && currencyResult.newCurrency !== undefined) {
                alert(`Earned ${currencyAmount} coins!`);
                // Currency display updated by fetchData wrapper
            }
        } else if (!saveSuccess) {
            alert("Failed to save stats after action.");
        }
    }

    function feedSlime() { performCareAction('feed', { hunger: 30, health: 5 }, 10); }
    function playWithSlime() { performCareAction('play', { happiness: 30, energy: -10, hunger: -5 }, 15); }
    function cleanSlime() { performCareAction('clean', { health: 20, happiness: 5 }, 10); }
    function sleepSlime() { performCareAction('sleep', { energy: 40, health: 10, happiness: -5 }, 5); }

    function updateCurrencyDisplay() { /* ... same as your previous correct version ... */ 
        const mainDisp = document.getElementById('currency-display'); 
        const storeDisp = document.getElementById('store-currency-display'); 
        const invDisp = document.getElementById('inventory-currency-display');
        const currentCoins = playerData.currency || 0;
        if(mainDisp) mainDisp.textContent = `Coins: ${currentCoins}`; 
        if(storeDisp) storeDisp.textContent = `Coins: ${currentCoins}`; 
        if(invDisp) invDisp.textContent = `Coins: ${currentCoins}`;
    }

    async function showStoreScreen() { /* ... same as your previous correct version, added await for saveSlimeData ... */ 
        if (document.getElementById('game-screen').classList.contains('active-screen') && slimeData) {
            await saveSlimeData();
        }
        // Ensure store items are fetched if not already present
        if (storeItems.length === 0) await fetchStoreItemsOnce();

        renderStoreItems(); 
        updateCurrencyDisplay(); 
        showScreen('store-screen'); 
    }

    function renderStoreItems() { /* ... same as your previous correct version ... */ 
        const listEl = document.getElementById('store-items-list'); if(!listEl) return; listEl.innerHTML = '';
        if (!storeItems || storeItems.length === 0) { listEl.innerHTML = '<li>No items in store.</li>'; return; }
        storeItems.forEach(item => {
            const li = document.createElement('li'); li.className = 'item-card'; li.dataset.itemId = item.itemId;
            let visual = (item.itemType === 'Color' && item.dataValue) ? `<div class="item-color-preview" style="background-color: ${item.dataValue};"></div>` : (item.dataValue && typeof item.dataValue === 'string' && item.dataValue.startsWith('http')) ? `<img src="${item.dataValue}" alt="${item.itemName}">` : '<div>?</div>';
            const owned = inventoryData.find(own => own.itemId === item.itemId); const qty = owned ? owned.quantity : 0;
            li.innerHTML = `${visual}<div class="item-name">${item.itemName}</div><div class="item-price">${item.price} Coins</div>${qty > 0 ? `<div class="equipped-status">Owned: ${qty}</div>` : ''}<button class="buy-btn">Buy</button>`;
            listEl.appendChild(li);
        });
        listEl.querySelectorAll('.buy-btn').forEach(b => b.addEventListener('click', handlePurchaseItem));
    }

    async function handlePurchaseItem(event) { /* ... same as your previous correct version ... */ 
        if (!playerData.playerId) { alert("Not logged in."); return; }
        const itemCard = event.target.closest('.item-card'); const itemId = itemCard.dataset.itemId; if(!itemId) return;
        const result = await fetchData('purchaseItem', 'POST', { playerId: playerData.playerId, itemId: itemId });
        if (result) { 
            await fetchAndRenderInventory(); // Re-fetch inventory to get updated quantities
            const itemDet = storeItems.find(i => i.itemId === itemId); 
            if(itemDet) alert(`Purchased ${itemDet.itemName}!`); else alert("Purchase successful!"); 
            renderStoreItems(); // Re-render store to update owned status
        }
    }

    async function showInventoryScreen() { /* ... same as your previous correct version, added await for saveSlimeData ... */ 
        if (document.getElementById('game-screen').classList.contains('active-screen') && slimeData) {
            await saveSlimeData();
        }
        // Ensure store items are loaded for item details
        if (storeItems.length === 0) await fetchStoreItemsOnce();
        await fetchAndRenderInventory(); 
        updateCurrencyDisplay(); 
        showScreen('inventory-screen');
    }

    async function fetchAndRenderInventory() { /* ... same as your previous correct version ... */ 
        const inv = await fetchData('getPlayerInventory', 'GET');
        if (inv) { inventoryData = inv; renderInventoryItems(); } 
        else { inventoryData = []; renderInventoryItems(); /* Keep showing empty inv screen */ }
    }

    function renderInventoryItems() { /* ... same as your previous correct version ... */ 
        const listEl = document.getElementById('inventory-items-list'); if(!listEl) return; listEl.innerHTML = '';
        if (!inventoryData || inventoryData.length === 0) { listEl.innerHTML = '<li>Inventory empty.</li>'; return; }
        if (storeItems.length === 0) console.warn("Store items catalog not loaded for inventory display details.");
        inventoryData.forEach(item => {
            const det = storeItems.find(si => si.itemId === item.itemId); // Get details from catalog
            const dv = det ? det.dataValue : (item.dataValue || null); 
            const iName = det ? det.itemName : (item.itemName || item.itemId); 
            const iType = det ? det.itemType : (item.itemType || 'Unknown');
            const li = document.createElement('li'); li.className = 'item-card inventory-item-card'; li.dataset.itemId = item.itemId;
            let visual = (iType === 'Color' && dv) ? `<div class="item-color-preview" style="background-color: ${dv};"></div>` : (dv && typeof dv === 'string' && dv.startsWith('http')) ? `<img src="${dv}" alt="${iName}">` : '<div>?</div>';
            const isEquipable = ['Color', 'Hat', 'Background'].includes(iType);
            const isCurrEq = slimeData && ((iType === 'Color' && slimeData.color === dv) || (iType === 'Hat' && slimeData.hat === item.itemId) || (iType === 'Background' && slimeData.background === item.itemId));
            li.innerHTML = `${visual}<div class="item-name">${iName}</div>${item.quantity > 0 ? `<div class="item-quantity">Qty: ${item.quantity}</div>` : ''}${isCurrEq ? `<div class="equipped-status">EQUIPPED</div>` : ''}${isEquipable && !isCurrEq ? `<button class="equip-btn">Equip</button>` : ''}`;
            listEl.appendChild(li);
        });
        listEl.querySelectorAll('.equip-btn').forEach(b => b.addEventListener('click', handleEquipItem));
    }

    async function handleEquipItem(event) { /* ... same as your previous correct version ... */ 
        if (!playerData.playerId || !slimeData || !slimeData.slimeId) { alert("Player/Slime not loaded."); return; }
        const itemCard = event.target.closest('.item-card'); const itemId = itemCard.dataset.itemId; if(!itemId) return;
        const itemDet = storeItems.find(i => i.itemId === itemId); // Use storeItems for details
        if (!itemDet) { alert("Error finding item details to equip."); return; }
        
        const result = await fetchData('equipItem', 'POST', { playerId: playerData.playerId, slimeId: slimeData.slimeId, itemId: itemId });
        if (result && result.updatedSlimeField) {
            if (result.updatedSlimeField === 'color') slimeData.color = result.equippedDataValue;
            else if (result.updatedSlimeField === 'hat') slimeData.hat = result.equippedItemId;
            else if (result.updatedSlimeField === 'background') slimeData.background = result.equippedItemId;
            
            await saveSlimeData(); // Save the slime with newly equipped item
            updateSlimeDisplay(); 
            renderInventoryItems(); // Re-render inventory to show updated equipped status
            alert(`${itemDet.itemName} equipped!`);
        }
    }
    
    // --- Minigame Functions ---
    function showMinigameSelectScreen() { /* ... same as your previous correct version ... */ 
        if (document.getElementById('game-screen').classList.contains('active-screen') && slimeData) saveSlimeData();
        updateCurrencyDisplay(); showScreen('minigame-select-screen');
    }
    function handleMinigameSelect(event) { /* ... same as your previous correct version ... */ 
        const btn = event.target.closest('.minigame-select-btn'); if(!btn) return; const gameType = btn.dataset.game; if(!gameType) return;
        if (!playerData.playerId || !slimeData) { alert("Log in & create slime first."); initializeGame(); return; }
        startMinigame(gameType);
    }
    function startMinigame(gameType) { /* ... same as your previous correct version ... */ 
        endCurrentMinigame(false); minigameState = { activeGame: gameType, timeLeft: MINIGAME_DURATION, score: 0, gameElements: [] };
        const screenContainerId = `minigame-${gameType}-screen`; const screenContainer = document.getElementById(screenContainerId);
        if(!screenContainer) { console.error("Minigame screen container not found:", screenContainerId); showScreen('minigame-select-screen'); return; }
        showScreen(screenContainerId);
        const minigameContainer = screenContainer.querySelector('.minigame-container'); if(minigameContainer) minigameContainer.style.display = 'flex'; else { console.error("Inner minigame container not found"); showScreen('minigame-select-screen'); return; }
        const timerEl = screenContainer.querySelector('.minigame-timer'); const scoreEl = screenContainer.querySelector('.minigame-score'); const msgEl = screenContainer.querySelector('.minigame-message'); const resEl = screenContainer.querySelector('.minigame-results');
        if(timerEl) timerEl.textContent = `Time: ${minigameState.timeLeft}`; if(scoreEl) scoreEl.textContent = `${gameType === 'tapper' ? 'Taps' : gameType === 'bubble' ? 'Popped' : 'Fed'}: ${minigameState.score}`; if(msgEl) msgEl.style.display = 'none'; if(resEl) resEl.style.display = 'none';
        switch (gameType) { case 'tapper': startSlimeTapper(); break; case 'bubble': startBubblePop(); break; case 'feed': startFeedTheSlime(); break; }
        minigameState.timer = setInterval(() => { minigameState.timeLeft--; if(timerEl) timerEl.textContent = `Time: ${minigameState.timeLeft}`; if (minigameState.timeLeft <= 0) endCurrentMinigame(true); }, 1000);
    }
    function endCurrentMinigame(processResults) { /* ... same as your previous correct version ... */ 
        if (!minigameState.activeGame) return; if(minigameState.timer) { clearInterval(minigameState.timer); minigameState.timer = null; }
        const activeGameType = minigameState.activeGame; // Store before resetting
        switch (activeGameType) {
            case 'tapper': const tsa = document.getElementById('tapper-slime-area'); if(tsa) tsa.removeEventListener('click', handleSlimeTap); break;
            case 'bubble': stopBubblePop(); break;
            case 'feed': stopFeedTheSlime(); break;
        }
        minigameState.gameElements.forEach(el => el.remove()); minigameState.gameElements = [];
        if (processResults) {
            displayMinigameResults(activeGameType, minigameState.score);
        } else { 
            const sc = document.getElementById(`minigame-${activeGameType}-screen`); 
            if(sc){ const me=sc.querySelector('.minigame-message'); const re=sc.querySelector('.minigame-results'); const mc=sc.querySelector('.minigame-container'); 
            if(me)me.style.display='none';if(re)re.style.display='none';if(mc)mc.style.display='none';}
        }
        minigameState.activeGame = null;
    }
    async function displayMinigameResults(gameType, score) { /* ... same as your previous correct version ... */ 
        const screenContainer = document.getElementById(`minigame-${gameType}-screen`); if(!screenContainer){ showScreen('minigame-select-screen'); return; }
        const resultsEl = screenContainer.querySelector('.minigame-results'); 
        const finalScoreEl = screenContainer.querySelector('.minigame-final-score') || (resultsEl ? resultsEl.querySelector('p:nth-child(1)') : null); 
        const coinsEl = screenContainer.querySelector('.minigame-coins-earned') || (resultsEl ? resultsEl.querySelector('p:nth-child(2)') : null); 
        const msgEl = screenContainer.querySelector('.minigame-message');
        let coinsEarned = 0; switch (gameType) { case 'tapper': coinsEarned = Math.floor(score / 3); break; case 'bubble': coinsEarned = score * 2; break; case 'feed': coinsEarned = score * 5; break; } coinsEarned = Math.max(0, coinsEarned);
        if(msgEl) { msgEl.textContent = "Time's Up!"; msgEl.style.display = 'block'; }
        if (coinsEarned > 0 && playerData.playerId) {
            const currencyResult = await fetchData('earnCurrency', 'POST', { playerId: playerData.playerId, amount: coinsEarned });
            if (currencyResult && currencyResult.newCurrency !== undefined) { if(coinsEl) coinsEl.textContent = `You earned ${coinsEarned} coins!`; updateCurrencyDisplay(); } else { if(coinsEl) coinsEl.textContent = `Failed to award coins.`; }
        } else { if(coinsEl) coinsEl.textContent = "You earned 0 coins."; }
        if(finalScoreEl) finalScoreEl.textContent = `Final Score: ${score}`; if(resultsEl) resultsEl.style.display = 'block'; if(msgEl) msgEl.style.display = 'none';
    }
    // Minigame Implementations (Slime Tapper, Bubble Pop, Feed The Slime)
    function startSlimeTapper() { /* ... same ... */ const sa=document.getElementById('tapper-slime-area'); if(sa) sa.addEventListener('click',handleSlimeTap); }
    function handleSlimeTap() { /* ... same ... */ if(minigameState.activeGame==='tapper'&&minigameState.timeLeft>0){minigameState.score++;const se=document.getElementById('tapper-score');if(se)se.textContent=`Taps: ${minigameState.score}`;const sle=document.getElementById('tapper-slime-area').querySelector('.slime');if(sle){sle.style.transform='scale(0.95)';setTimeout(()=>{sle.style.transform='scale(1)';},100);}}}
    let bubbleInterval; 
    function startBubblePop() { /* ... same ... */ const ga=document.getElementById('bubble-game-area'); if(!ga){endCurrentMinigame(false);return;} bubbleInterval=setInterval(createBubble,BUBBLE_CREATE_DELAY);}
    function createBubble() { /* ... same ... */ if(minigameState.timeLeft<=0||minigameState.activeGame!=='bubble')return;const ga=document.getElementById('bubble-game-area');const b=document.createElement('div');b.className='minigame-target bubble';const gaw=ga.clientWidth;const bs=30;const rx=Math.random()*(gaw-bs);b.style.left=`${rx}px`;b.style.bottom=`-${bs}px`;b.addEventListener('click',handleBubbleClick);ga.appendChild(b);minigameState.gameElements.push(b);b.addEventListener('animationend',()=>{removeMinigameElement(b);});}
    function handleBubbleClick(event) { /* ... same ... */ if(minigameState.activeGame==='bubble'&&minigameState.timeLeft>0){event.stopPropagation();const b=event.target;minigameState.score++;const se=document.getElementById('bubble-score');if(se)se.textContent=`Popped: ${minigameState.score}`;removeMinigameElement(b);}}
    function stopBubblePop() { /* ... same ... */ if(bubbleInterval){clearInterval(bubbleInterval);bubbleInterval=null;}}
    let foodTimeout;
    function startFeedTheSlime() { /* ... same ... */ const ga=document.getElementById('feed-game-area');if(!ga){endCurrentMinigame(false);return;}ga.addEventListener('click',handleMissedClickInFeedGame);scheduleNextFood();}
    function createFoodTarget() { /* ... same ... */ if(minigameState.timeLeft<=0||minigameState.activeGame!=='feed'){foodTimeout=null;return;}const ga=document.getElementById('feed-game-area');const f=document.createElement('img');f.src='https://i.imgur.com/ExampleFood.png';f.className='minigame-target food';const gar=ga.getBoundingClientRect();const fs=40;const p=50;const rx=p+Math.random()*(gar.width-fs-2*p);const ry=p+Math.random()*(gar.height-fs-2*p);f.style.position='absolute';f.style.left=`${rx}px`;f.style.top=`${ry}px`;f.addEventListener('click',handleFoodClick);ga.appendChild(f);minigameState.gameElements.push(f);const rt=setTimeout(()=>{removeMinigameElement(f);scheduleNextFood();},FOOD_LIFESPAN);f._removalTimerId=rt;foodTimeout=null;}
    function handleFoodClick(event) { /* ... same ... */ if(minigameState.activeGame==='feed'&&minigameState.timeLeft>0){event.stopPropagation();const f=event.target;minigameState.score++;const se=document.getElementById('feed-score');if(se)se.textContent=`Fed: ${minigameState.score}`;if(f._removalTimerId)clearTimeout(f._removalTimerId);removeMinigameElement(f);scheduleNextFood();}}
    function handleMissedClickInFeedGame(event) { /* ... same ... */ if(minigameState.activeGame==='feed'&&minigameState.timeLeft>0){const fe=document.querySelectorAll('#feed-game-area .minigame-target.food');if(fe.length>0)console.log('Missed click!');}}
    function scheduleNextFood() { /* ... same ... */ if(minigameState.timeLeft<=0||minigameState.activeGame!=='feed')return;if(foodTimeout===null)foodTimeout=setTimeout(createFoodTarget,FOOD_CREATE_DELAY);}
    function stopFeedTheSlime() { /* ... same ... */ if(foodTimeout){clearTimeout(foodTimeout);foodTimeout=null;}const ga=document.getElementById('feed-game-area');if(ga)ga.removeEventListener('click',handleMissedClickInFeedGame);}
    function removeMinigameElement(element) { /* ... same ... */ if(element&&element.parentNode){if(element._removalTimerId)clearTimeout(element._removalTimerId);element.parentNode.removeChild(element);minigameState.gameElements=minigameState.gameElements.filter(el=>el!==element);}}

    // --- Event Listeners ---
    function setupEventListeners() { /* ... same as your previous correct version (uses showScreen) ... */ 
        const lb=document.getElementById('login-button');if(lb)lb.addEventListener('click',handleLogin);
        const csb=document.getElementById('create-slime-button');if(csb)csb.addEventListener('click',handleCreateSlime);
        const fb=document.getElementById('feed-btn');if(fb)fb.addEventListener('click',feedSlime);
        const pb=document.getElementById('play-btn');if(pb)pb.addEventListener('click',playWithSlime);
        const cb=document.getElementById('clean-btn');if(cb)cb.addEventListener('click',cleanSlime);
        const sb=document.getElementById('sleep-btn');if(sb)sb.addEventListener('click',sleepSlime);
        const nc=document.querySelector('.nav-container');if(nc)nc.addEventListener('click',async(e)=>{const ni=e.target.closest('.nav-item');if(!ni)return; const ogs=document.getElementById('game-screen').classList.contains('active-screen');const oms=document.getElementById('minigame-select-screen').classList.contains('active-screen');if((ogs||oms)&&slimeData)await saveSlimeData();const navId=ni.id;switch(navId){case'home-nav':if(playerData.playerId&&slimeData){showScreen('game-screen');startGameLoop();}else if(playerData.playerId)showScreen('create-slime-screen');else showScreen('login-screen');break;case'store-nav':if(playerData.playerId)showStoreScreen();else{alert("Log in for store.");showScreen('login-screen');}break;case'inventory-nav':if(playerData.playerId)showInventoryScreen();else{alert("Log in for inventory.");showScreen('login-screen');}break;case'minigames-nav':if(playerData.playerId&&slimeData)showMinigameSelectScreen();else if(playerData.playerId){alert("Create slime first!");showScreen('create-slime-screen');}else{alert("Log in for minigames.");showScreen('login-screen');}break;}});
        const mss=document.getElementById('minigame-select-screen');if(mss)mss.addEventListener('click',handleMinigameSelect);
        const me=document.querySelector('main');if(me)me.addEventListener('click',(e)=>{const bb=e.target.closest('.minigame-back-btn');if(!bb)return;const ts=bb.dataset.target;if(ts){endCurrentMinigame(false);showScreen(ts);}});
    }
    function setActiveNav() { /* ... same ... */ const hn=document.getElementById('home-nav');if(hn)hn.classList.add('active'); }
    function createHearts() { /* ... same ... */ const c=document.getElementById('hearts-container');if(!c)return;c.innerHTML='';for(let i=0;i<20;i++){const h=document.createElement('div');h.className='heart';h.innerHTML='❤️';h.style.left=`${Math.random()*100}vw`;h.style.animationDuration=`${15+Math.random()*10}s`;h.style.animationDelay=`${Math.random()*5}s`;h.style.fontSize=`${20+Math.random()*20}px`;c.appendChild(h);}}

    // Initialize on page load
    window.addEventListener('load', () => { createHearts(); setupEventListeners(); initializeGame(); });
    window.addEventListener('beforeunload', (event) => { if (slimeData && playerData.playerId) { console.log("Attempting save before unload..."); saveSlimeData(); /* event.preventDefault(); event.returnValue = ''; */ } });
</script>
</body>
</html>